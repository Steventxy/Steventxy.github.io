<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java中看似简单实际很坑的题</title>
    <url>/2020/04/06/Java%E4%B8%AD%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95%E5%AE%9E%E9%99%85%E5%BE%88%E5%9D%91%E7%9A%84%E9%A2%98/</url>
    <content><![CDATA[<img src="https://blog.steventan.top/images/Java中看似简单实际很坑的题/vzX5MYeyARD4kcT.png" alt="java.png" style="zoom: 67%;" />

<h3 id="第一题（貌似是考察方法的参数传递）"><a href="#第一题（貌似是考察方法的参数传递）" class="headerlink" title="第一题（貌似是考察方法的参数传递）"></a>第一题（貌似是考察方法的参数传递）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    method(a,b);<span class="comment">//在调用method()方法之后输出a = 100,b = 200</span></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//代码编写处</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在method中直接写</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span>;</span><br><span class="line">b = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<p>这个样子会直接被别人鄙视</p>
<p>其实这是一个脑筋急转弯的题目，直接像上面这样把一个基本数据类型的变量，作为形参传入函数，等于是直接把值赋给了函数中的实参，改变函数中的实参并不会影响主函数中a和b的值，在method()方法调用完之后，方法中的实参a和b就出栈了，此时在主函数输出的仍然是10和20。</p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>机智的方法，调用完method()方法之后就直接退出程序，不让他执行主函数中的print方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  a = <span class="number">100</span>;</span><br><span class="line">  b = <span class="number">200</span>;</span><br><span class="line">  System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">  System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">  System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  PrintStream ps = <span class="keyword">new</span> PrintStream(System.out)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"a = 10"</span>.equals(x))&#123;</span><br><span class="line">                x = <span class="string">"a = 100"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"b = 10"</span>.equals(x))&#123;</span><br><span class="line">                x = <span class="string">"b = 200"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.setOut(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法用的是重写，当要调用println()这个方法分时候不是调用Java库中的println()方法，而是调用这里自己写的这个，就把要输出的“a = 10”替换成了”a = 100”。</p>
<h3 id="第二题（微软面试题）"><a href="#第二题（微软面试题）" class="headerlink" title="第二题（微软面试题）"></a>第二题（微软面试题）</h3><blockquote>
<p>定义一个int型的数组: int[] arr = new int]{12,3,3,34,56,77,432};让数组的每个位置上的值去除以首位置的元素,得到的结果,作为该位置上的新值。遍历新的数组。</p>
</blockquote>
<p>这个题其实很简单，但是一不小心就会出错，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)</span><br><span class="line">  arr[i] = arr[i]/arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>自己一顿操作之后以为稳了，实际上结果和原数组是一样的。这样从前面向后面遍历，数组第一个值在第一次就变成1了，之后每次除的arr[0]都是1，所以后面的值都没有发生变化。</p>
<p>所以简单的题不要掉以轻心。</p>
<p>正确的写法很简单也不止一种方法，可以从后向前遍历数组，也可以把数组的第一个值赋给一个临时变量，后面的数都除以这个临时变量。</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">    System.out.println(arr2); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问输出的分别是什么？</p>
<p>正确答案是arr1输出的是地址值，arr2输出的是abc。</p>
<p>这其实考的是一个很细的知识点，了解过后就会感觉这个题很low，简直是在是在侮辱自己的智商，不了解的话可能就认为两个都是输出一个地址值。</p>
<p>这里涉及到了Java中方法的重载，同一个函数名，但是传的参数个数或者参数类型不同的话，他调的方法是不一样的。</p>
<p>第一个整型的数组，传入的是object类型，调用的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">  String s = String.valueOf(x);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    print(s);</span><br><span class="line">    newLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个字符型的数组，传入的是char型的数组，调用的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    print(x);</span><br><span class="line">    newLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><blockquote>
<p> 如下两个题目输出结果相同吗？各是什么：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o1);</span><br><span class="line"></span><br><span class="line">Object o2;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>)</span><br><span class="line">  o2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  o2 = <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o2);</span><br></pre></td></tr></table></figure>

<p>正确答案：</p>
<p>o1输出的是1.0，o2输出的是1</p>
<p>这个题是看似在考Object类中的方法，但是实际上，这里的三元运算符涉及到一个自动类型提升的问题</p>
<p>(表达式1)?(表达式2):(表达式3)</p>
<p>三元运算的最后结果是这三个表达式中的类型“最高”的一种，在计算的过程个中会有自动类型提升</p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">  Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">  System.out.println(i == j);</span><br><span class="line">  Integer m = <span class="number">1</span>;</span><br><span class="line">  Integer n = <span class="number">1</span>;</span><br><span class="line">  System.out.println(m == n);<span class="comment">//</span></span><br><span class="line">  Integer x = <span class="number">128</span>;</span><br><span class="line">  Integer y = <span class="number">128</span>;</span><br><span class="line">  System.out.println(x == y);<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个输出为false，第二个输出为true，第三个输出为false。</p>
<p>Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],保存了从- 128 ~ 127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在 -128 ~ 127范围内时，可以直接使用数组中的元素，不用再去new了。目的：提高效率。</p>
<p>Integer类中的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">      sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">        i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">        <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">        h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">        <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">      cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><p>改错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> C().pX();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误在第9行,<code>System.out.println(x);</code></p>
<p>因为C这个类既继承了B类又要实现A接口，然而接口A和类B中有一个同名的变量x,C类中又要输出x的值，此时编译器就不知道这个x到底是接口A中的还是父类B中的，所以就会有ambiguous。</p>
<p>如果是要输出接口A中的x就直接sout(A.x)，如果要输出父类中的x就sout(super.x)</p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><p>找错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Playable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Rollable</span> <span class="keyword">extends</span> <span class="title">Playable</span>, <span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">  Ball ball = <span class="keyword">new</span> Ball(<span class="string">"PingPang"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">implements</span> <span class="title">Rollable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Ball</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ball = <span class="keyword">new</span> Ball(<span class="string">"Football"</span>);</span><br><span class="line">    System.out.println(ball.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个可能题很容易会认为是两个接口中的play()方法重名了，Ball子类不知道是实现的哪一个。</p>
<p>实际上这种情况是两个接口中的方法都实现了，主要的问题是在19行ball是接口Rollable中定义的一个Ball类型的变量，二接口中的变量都是默认被final修饰了的，所以值不能被修改。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识总结（上）</title>
    <url>/2020/04/14/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Java中的注释"><a href="#Java中的注释" class="headerlink" title="Java中的注释"></a>Java中的注释</h2><ol>
<li><p>单行注释   //</p>
</li>
<li><p>多行注释  /*   */</p>
<p>单行注释和多行注释的作用：</p>
<p>① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人</p>
<p>② 调试所写的代码</p>
</li>
<li><p>文档注释  /**   */</p>
<p>注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<hr>
</li>
</ol>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ol>
<li><p>标识符：凡是自己可以起名字的地方都叫标识符。</p>
<p>  比如：类名、变量名、方法名、接口名、包名…</p>
</li>
<li><p>标识符的命名规则：–&gt; 如果不遵守如下的规则，编译不通过！</p>
<p>① 由26个英文字母大小写，0-9 ，_或 $ 组成 </p>
<p>②数字不可以开头。</p>
<p>③不可以使用关键字和保留字，但能包含关键字和保留字。</p>
<p>④Java中严格区分大小写，长度无限制。</p>
<p>⑤标识符不能包含空格。</p>
</li>
<li><p>Java中的名称命名规范： —&gt;如果不遵守如下的规范，编译可以通过！</p>
<p>包名：多单词组成时所有字母都小写：xxxyyyzzz</p>
<p>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</p>
<p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</p>
<p>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p>
</li>
<li><p>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</p>
<p>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。 </p>
<hr>
</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><p>变量按照数据类型来分：<br>a. 基本数据类型：</p>
<p>​    整型：byte \ short \ int \ long</p>
<p>​    浮点型：float \ double</p>
<p>​    字符型：char</p>
<p>​    布尔型：boolean</p>
<p> b. 引用数据类型：</p>
<pre><code>类(class)

   接口(interface)

   数组(array)</code></pre></li>
</ol>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">占用存储空间</th>
<th align="center">表示数据范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1字节=8bit</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">-2^15 ~2^15 -1</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">-2^31 ~2^31 -1</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">-2^62 ~2^62 -1</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4字节</td>
<td align="center">-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8字节</td>
<td align="center">-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
<ul>
<li><strong>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</strong> </li>
<li><strong>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</strong></li>
</ul>
<p>转义字符：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>退格符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\\</td>
<td>反斜线</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>变量在类中声明的位置：</p>
<p>​    成员变量 vs 局部变量</p>
</li>
</ol>
<h3 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h3><ol>
<li><p>java定义变量的格式：数据类型 变量名 = 变量值;</p>
</li>
<li><p>说明：</p>
<p>  ① 变量必须先声明，后使用</p>
<p>  ② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了</p>
<p>  ③ 同一个作用域内，不可以声明两个同名的变量</p>
</li>
</ol>
<h3 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h3><p>基本数据类型之间的运算规则：</p>
<p>前提：这里讨论只是7种基本数据类型变量间的运算。不包含boolean类型的。</p>
<ol>
<li><p>自动类型提升：</p>
<p> 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p>
  <pre class="mermaid">   graph LR
char --> int
byte --> int
short --> int --> long --> float --> double</pre>

<p> 特别的：byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。当byte、char、short三种类型的变量做运算时，结果为int型。</p>
</li>
<li><p>强制类型转换：</p>
<p>a.需要使用强转符：()</p>
<p>b.注意点：强制类型转换，可能导致精度损失。</p>
</li>
<li><p>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p>
</li>
</ol>
<h3 id="String类型变量的使用"><a href="#String类型变量的使用" class="headerlink" title="String类型变量的使用"></a>String类型变量的使用</h3><ol>
<li><p>String属于引用数据类型,翻译为：字符串</p>
</li>
<li><p>声明String类型变量时，使用一对” “</p>
</li>
<li><p>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+</p>
</li>
<li><p>运算的结果仍然是String类型</p>
<hr>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>太简单，不说了</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>介绍一个特别的：instanceof</p>
<p>作用是检查是否是类的对象，例如： “Hello” instanceof String = true</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp;—逻辑与         | —逻辑或       ！—逻辑非 </p>
<p>&amp;&amp; —短路与     || —短路或     ^ —逻辑异或</p>
<ul>
<li>“&amp;”和“&amp;&amp;”的区别： <ul>
<li>单&amp;时，左边无论真假，右边都进行运算； </li>
<li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 </li>
</ul>
</li>
<li>“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</li>
</ul>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>格式： (表达式1)?表达式2：表达式3；</p>
<p>若表达式1的结果为真则执行<strong>表达式2</strong>，若为假则执行<strong>表达式3</strong></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p>表达式1,表达式2,表达式3的类型可以不同，进行自动类型转换（提升）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o1 = <span class="keyword">true</span> ? <span class="keyword">new</span> Integer(<span class="number">1</span>) : <span class="keyword">new</span> Double(<span class="number">2.0</span>);</span><br><span class="line">System.out.println(o1);<span class="comment">//1.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>条件表达式不能取代一般的if语句,仅当if语句中内嵌的语句为赋值语句(且两个分支都给同一变量赋值)时才能代替if语句，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">  printf(<span class="string">"even/n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  printf(<span class="string">"odd/n"</span>);</span><br><span class="line"><span class="comment">//不能写成</span></span><br><span class="line">(a%<span class="number">2</span>==<span class="number">0</span>)?printf(<span class="string">"even/n"</span>):printf(<span class="string">"odd/n"</span>);</span><br><span class="line"><span class="comment">//但是可以写成</span></span><br><span class="line">printf(<span class="string">"%s/n"</span>,(a%<span class="number">2</span>==<span class="number">0</span>?<span class="string">"even"</span>:<span class="string">"odd"</span>);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><table>
<thead>
<tr>
<th align="center">运算顺序（从左往右或从右往左）</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">.    ()      {}      ;      ,</td>
</tr>
<tr>
<td align="center">R –&gt; L</td>
<td align="center">++  –  ~    !()</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">*      /     %</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&lt;&lt;  &gt;&gt;   &gt;&gt;&gt;</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&lt;  &gt;  &lt;=  &gt;=    instanceof</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">==      !=</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&amp;</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">&amp;&amp;</td>
</tr>
<tr>
<td align="center">L –&gt; R</td>
<td align="center">||</td>
</tr>
<tr>
<td align="center">R –&gt; L</td>
<td align="center">?    :</td>
</tr>
<tr>
<td align="center">R –&gt; L</td>
<td align="center">=    *=    /=   %=</td>
</tr>
</tbody></table>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括 基本数据类型和引用数据类型。</li>
<li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是 这块连续空间的首地址。 </li>
<li>数组的长度一旦确定，就不能修改。 </li>
<li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ol>
<li><p>一维数组的声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type <span class="keyword">var</span>[] 或 type[] <span class="keyword">var</span>；</span><br></pre></td></tr></table></figure>

<p>Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; <strong>//非法</strong></p>
</li>
<li><p>初始化</p>
<ul>
<li><p>动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">String names[];</span><br><span class="line">names = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">names[<span class="number">0</span>] = “钱学森”;</span><br><span class="line">names[<span class="number">1</span>] = “邓稼先”;</span><br><span class="line">names[<span class="number">2</span>] = “袁隆平”;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>静态初始化：在定义数组的同时就为数组元素分配空间并赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">String names[] = &#123;</span><br><span class="line">“李四光”,“茅以升”,“华罗庚”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="数组元素的默认初始化值"><a href="#数组元素的默认初始化值" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><table>
<thead>
<tr>
<th align="center">数组元素类型</th>
<th align="center">元素默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0F</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">0或‘\u0000’(表现为空)</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">应用类型</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><ol>
<li><p>声明和初始化</p>
<ul>
<li><p>格式1（动态初始化）：int[][] arr = new int[3][2];</p>
<p>定义了名称为arr的二维数组 </p>
<p>二维数组中有3个一维数组 </p>
<p>每一个一维数组中有2个元素 一维数组的名称分别为arr[0], arr[1], arr[2] </p>
<p>给第一个一维数组1脚标位赋值为78写法是：arr[0][1] = 78;</p>
</li>
<li><p>格式2（动态初始化）：int[][] arr = new int[3][];</p>
<p>二维数组中有3个一维数组。 </p>
<p>每个一维数组都是默认初始化值null (注意：区别于格式1）</p>
<p> 可以对这个三个一维数组分别进行初始化 </p>
<p>arr[0] = new int[3]; arr[1] = new int[1]; </p>
<p>arr[2] = new int[2]; </p>
</li>
</ul>
<p><strong>注： int[][]arr = new int[][3]; //非法</strong></p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之多线程</title>
    <url>/2020/05/17/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="程序、进程、线程的基本概念"><a href="#程序、进程、线程的基本概念" class="headerlink" title="程序、进程、线程的基本概念"></a>程序、进程、线程的基本概念</h1><h2 id="程序（program）"><a href="#程序（program）" class="headerlink" title="程序（program）"></a>程序（program）</h2><p>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p>
<h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h2><p>是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。</p>
<ul>
<li>如：运行中的QQ，运行中的MP3播放器 </li>
<li>程序是静态的，进程是动态的 </li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
<a id="more"></a>

<h2 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h2><p>进程可进一步细化为线程，是一个程序内部的一条执行路径。若一个进程同一时间并行执行多个线程，就是支持多线程的。线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销比进程小。一个进程中的多个线程共享相同的内存单元/内存地址空间 -&gt; 它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事</p>
<p>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。</p>
<h1 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h1><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>Thread()：创建新的Thread对象</li>
<li>Thread(String threadName)：创建线程，并指定线程实例</li>
<li>Thread(Runnable target)：指定创建线程的目标对象，他实现了Runnable接口中的run方法</li>
<li>Thread(Runnable target, String name)：创建新的Thread对象</li>
</ol>
<h3 id="常见的方法"><a href="#常见的方法" class="headerlink" title="常见的方法"></a>常见的方法</h3><ol>
<li>void start(): 启动线程，并执行对象的run()方法 </li>
<li>run(): 线程在被调度时执行的操作 </li>
<li>String getName(): 返回线程的名称 </li>
<li>void setName(String name):设置该线程名称 </li>
<li>static Thread currentThread(): 返回当前线程，在Thread子类中就 是this</li>
<li>static void yield()：线程让步，暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程</li>
<li>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止，优先级比当前线程低的线程也可以获取到执行权</li>
<li>static void sleep(long millis)：(指定时间:毫秒) ，令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队，此方法抛出了InterruptedException。</li>
</ol>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h3><p>具体步骤：</p>
<ol>
<li>定义子类继承Thread类</li>
<li>子类重写Thread类中的run()方法</li>
<li>创建Thread子类对象，即创建线程的对象</li>
<li>启动线程，调用线程对象的start()方法</li>
</ol>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">    t1.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li>
<li>想要启动多线程，必须调用start方法。</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出异常 “IllegalThreadStateException”。</li>
</ol>
<h3 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h3><p>具体步骤：</p>
<ol>
<li>定义子类，实现Runnable接口</li>
<li>子类重写Runnable接口中的run()方法</li>
<li>通过Thread类含参构造器创建线程对象，将Runnable接口的子类对象作为实际参数传递给Thread类的构造器</li>
<li>调用Thread类的start()方法</li>
</ol>
<h3 id="继承方式与实现方式的区别"><a href="#继承方式与实现方式的区别" class="headerlink" title="继承方式与实现方式的区别"></a>继承方式与实现方式的区别</h3><ol>
<li>继承Thread类：线程代码存放在Thread子类run()方法中</li>
<li>实现Runnable：线程代码存放在接口子类的run() 方法中</li>
<li>实现的方法避免了单继承的局限性</li>
<li>多个线程可以共享同一个接口实现类的对象，比较适合多个线程来处理同一份资源</li>
</ol>
<h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><p>java中线程的调度策略是抢占式的，高优先级的线程抢占CPU</p>
<p>java中线程的调度方法：</p>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><h3 id="线程的优先等级"><a href="#线程的优先等级" class="headerlink" title="线程的优先等级"></a>线程的优先等级</h3><ul>
<li>MAX_PRIORITY：10  最高优先级</li>
<li>MIN _PRIORITY：1  最低优先级</li>
<li>NORM_PRIORITY：5  默认优先级</li>
</ul>
<h4 id="相关的方法"><a href="#相关的方法" class="headerlink" title="相关的方法"></a>相关的方法</h4><ol>
<li>getPriority()：获取线程的优先等级</li>
<li>setPriority()：设置线程的优先级</li>
</ol>
<p>说明：</p>
<ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并不一定是在高优先级的线程之后才被调用</li>
</ul>
<h3 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h3><p>Java中的线程分为两类：一种是守护线程，一种是用户线程</p>
<p>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。守护线程是用来服务用户线程的，通过在start()方法前调用 thread.setDaemon(true)可以把一个用户线程变成一个守护线程。Java垃圾回收就是一个典型的守护线程。若JVM中都是守护线程，当前JVM将退出。 </p>
<p>形象理解：兔死狗烹，鸟尽弓藏</p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p><strong>JDK中用Thread.State类定义了线程的几种状态</strong></p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ul>
<li>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建 状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 </li>
<li>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 </li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 </li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
<img src="https://blog.steventan.top/images/Java基础之多线程/image-20200518193548122.png" alt="image-20200518193548122" style="zoom:80%;" />

<h1 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h1><p>多个线程操作同一个共享的数据会出现线程的安全问题，为了解决这一问题，就引入了线程的同步</p>
<p>比如：如果两个人同时操作一个银行账户，进行取钱操作，如果账户里面有一千元，甲要取1000，乙也要取1000，如果甲进入到取钱的操作里面（进入取钱之前有个判断，如果取的钱小于账户余额才能进入），但是还没有按下最后的取钱按钮（账户余额还是没变），这个时候乙也进入到取钱的页面了（现在余额还是1000，所以可以进入），最后两个人都按下取钱的按钮，银行账户就会出现-1000元的情况。显然，这是不合理的。</p>
<p>再举个例子：模拟火车站售票程序，同时开启三个售票窗口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">100</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                           <span class="string">"售出车票，tick号为："</span> + tick--);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Ticket t = <span class="keyword">new</span> Ticket();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    t1.setName(<span class="string">"t1窗口"</span>);</span><br><span class="line">    t2.setName(<span class="string">"t2窗口"</span>);</span><br><span class="line">    t3.setName(<span class="string">"t3窗口"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这种写法也是存在线程不安全问题，举一个最简单的情况，当tick为1时，如果线程1进入到if判断里面，但是还没有执行tick–，这个时候线程2也是可以进入到if判断里面的，但是最后输出的时候就会出现票号为0的票。如果在线程1还没将tick–之前，线程3也进入到if里面了，那最后会输出一个-1号票，这就是线程的不安全问题。</p>
<p>用个图来直观的表示：</p>
<img src="https://blog.steventan.top/images/Java基础之多线程/image-20200518203236660.png" alt="image-20200518203236660" style="zoom:80%;" />

<p>很显然，这里出现的线程安全问题是因为：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。</p>
<p>要解决这个问题也很简单，就是在同一个时间内只让一个线程操作与共享数据相关的代码，在这部分代码没执行完之前，其他进程不能执行这部分代码。</p>
<h2 id="Synchronized的使用方法"><a href="#Synchronized的使用方法" class="headerlink" title="Synchronized的使用方法"></a>Synchronized的使用方法</h2><ul>
<li>Java对于多线程的安全问题提供了专业的解决方式：同步机制</li>
</ul>
<p>有两种方式来使用这个同步机制：</p>
<ol>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;<span class="comment">//这个对象是用来充当同步监视器的，俗称锁</span></span><br><span class="line">  <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized还可以放在方法声明中，表示整个方法为同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="同步机制中的锁"><a href="#同步机制中的锁" class="headerlink" title="同步机制中的锁"></a>同步机制中的锁</h3><blockquote>
<p>在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p>
</blockquote>
<p>synchronized的锁是什么？</p>
<ul>
<li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（同步监视器）</li>
<li>同步方法的锁：静态方法（类名.class）、非静态方法（this） </li>
<li>同步代码块：自己指定，很多时候也是指定为this或类名.class</li>
</ul>
<p>注意：</p>
<ol>
<li>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则任然无法保证共享资源的安全</li>
<li>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</li>
</ol>
<h2 id="同步范围的确定"><a href="#同步范围的确定" class="headerlink" title="同步范围的确定"></a>同步范围的确定</h2><p>判断代码是否存在线程安全问题：</p>
<ol>
<li>明确哪些代码是被多线程执行的</li>
<li>多个线程之间是否存在共享数据</li>
<li>多线程运行代码中是否有多条语句操作共享数据</li>
</ol>
<p>注意：</p>
<p>同步代码范围太大：没有发挥出多线程的功能</p>
<p>同步代码范围太小：不能解决存在的安全问题</p>
<h2 id="线程释放锁的操作"><a href="#线程释放锁的操作" class="headerlink" title="线程释放锁的操作"></a>线程释放锁的操作</h2><ol>
<li>当前线程的同步方法、同步代码块执行结束。 </li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。 </li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。 </li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ol>
<p>注意：</p>
<ol>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法当前线程不会释放锁</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁</li>
</ol>
<p>讲到这里，我们解决一下上面火车票售票那个示例和之前单例模式的懒汉式的线程不安全问题</p>
<p>火车售票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">100</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + </span><br><span class="line">                             <span class="string">"售出车票，tick号为："</span> + tick--);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Ticket t = <span class="keyword">new</span> Ticket();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">    t1.setName(<span class="string">"t1窗口"</span>);</span><br><span class="line">    t2.setName(<span class="string">"t2窗口"</span>);</span><br><span class="line">    t3.setName(<span class="string">"t3窗口"</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例设计模式之懒汉式(线程安全)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;<span class="comment">//加上这个判断可以提高运行的效率</span></span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">          instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Singleton s1=Singleton.getInstance();</span><br><span class="line">    Singleton s2=Singleton.getInstance();</span><br><span class="line">    System.out.println(s1==s2);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h2><ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 </li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">final</span> StringBuffer s2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">          s2.append(<span class="string">"A"</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">            s2.append(<span class="string">"B"</span>);</span><br><span class="line">            System.out.print(s1);</span><br><span class="line">            System.out.print(s2);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s2) &#123;</span><br><span class="line">          s2.append(<span class="string">"C"</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (s1) &#123;</span><br><span class="line">            s1.append(<span class="string">"D"</span>);</span><br><span class="line">            System.out.print(s2);</span><br><span class="line">            System.out.print(s1);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h2><p>在JDK5.0之后，Java提供了更强大的线程同步机制——通过显示的定义同步锁对象来实现同步，这里的同步锁用Lock对象充当。</p>
<p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
<p>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和 内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//保证线程安全的代码;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果同步代码有异常，要将unlock()写入finally语句块</p>
<h2 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h2><ol>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放 </li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁 </li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
</ol>
<h1 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h1><p>先介绍几种线程通信要用到的几种方法：</p>
<ul>
<li><p>wait():</p>
<p>令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</p>
</li>
<li><p>notify():</p>
<p>唤醒正在排队等待同步资源的线程中优先级最高的</p>
</li>
<li><p>notifyAll():</p>
<p>唤醒正在排队等待同步资源的所有线程</p>
</li>
</ul>
<p>注意：</p>
<ol>
<li>这三个方法只有在synchronized方法或代码块中才能使用，否则会报java.lang.IllegalMonitorStateException</li>
<li>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁，因此这三个方法只能在Object类中声明</li>
</ol>
<h2 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h2><p>在当前线程中调用方法： 对象名.wait() </p>
<p>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出notify (或notifyAll) 为止。 </p>
<p>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） </p>
<p>调用此方法后，当前线程将释放对象监控权 ，然后进入等待 </p>
<p>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</p>
<h2 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h2><p>在当前线程中调用方法： 对象名.notify() </p>
<p>功能：唤醒等待该对象监控权的一个/所有线程。 </p>
<p>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</p>
<h1 id="JDK5-0新增线程创建方式"><a href="#JDK5-0新增线程创建方式" class="headerlink" title="JDK5.0新增线程创建方式"></a>JDK5.0新增线程创建方式</h1><h2 id="新增方式一：实现Callable接口"><a href="#新增方式一：实现Callable接口" class="headerlink" title="新增方式一：实现Callable接口"></a>新增方式一：实现Callable接口</h2><p>与使用Runnable相比， Callable功能更强大些 </p>
<ul>
<li>相比run()方法，可以有返回值 </li>
<li>方法可以抛出异常 </li>
<li>支持泛型的返回值 </li>
<li>需要借助FutureTask类，比如获取返回结果</li>
</ul>
<p>Future接口 </p>
<ul>
<li><p>可以对具体Runnable、Callable任务的执行结果进行取消、查询是 否完成、获取结果等。 </p>
</li>
<li><p>FutrueTask是Futrue接口的唯一的实现类 </p>
</li>
<li><p>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</p>
</li>
</ul>
<h2 id="新增方式二：使用线程池"><a href="#新增方式二：使用线程池" class="headerlink" title="新增方式二：使用线程池"></a>新增方式二：使用线程池</h2><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。 </p>
<p>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。 </p>
<p>好处： </p>
<ol>
<li>提高响应速度（减少了创建新线程的时间） </li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建） </li>
<li>便于线程管理 <ul>
<li>corePoolSize：核心池的大小 </li>
<li>maximumPoolSize：最大线程数 </li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ol>
<h3 id="线程池相关API"><a href="#线程池相关API" class="headerlink" title="线程池相关API"></a>线程池相关API</h3><p>JDK 5.0起提供了线程池相关API：ExecutorService 和 Executors </p>
<p>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor </p>
<ul>
<li><p>void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable </p>
</li>
<li><p>Future submit(Callable task)：执行任务，有返回值，一般又来执行 Callable </p>
</li>
<li><p>void shutdown() ：关闭连接池 </p>
</li>
</ul>
<p>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>
<ul>
<li><p>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 </p>
</li>
<li><p>Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池 </p>
</li>
<li><p>Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 </p>
</li>
<li><p>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识总结（下）</title>
    <url>/2020/05/06/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>在Java中声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”</p>
<ul>
<li><p>final标记的类不能被继承。提高安全性，提高程序的可读性。</p>
<p>例如：String类、System类、StringBuffer类</p>
</li>
<li><p>final标记的方法不能被子类重写。 </p>
<p>例如：Object类中的getClass()。</p>
</li>
<li><p>final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。</p>
</li>
</ul>
<h3 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123; <span class="comment">//错误，不能被继承。</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中国古代，什么人不能有后代，就可以被final声明，称为“太监类”</p>
<a id="more"></a>

<h3 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"A"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">// 错误，不能被重写。</span></span><br><span class="line">  	System.out.println(<span class="string">"B"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final修饰变量—常量"><a href="#final修饰变量—常量" class="headerlink" title="final修饰变量—常量"></a>final修饰变量—常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String INFO = <span class="string">"test"</span>; <span class="comment">//声明常量</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//The final field A.INFO cannot be assigned</span></span><br><span class="line">    INFO = <span class="string">"尚硅谷"</span>;<span class="comment">//错误，final修饰的变量不能被改变</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final举例应用"><a href="#final举例应用" class="headerlink" title="final举例应用"></a>final举例应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> totalNumber = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> ID;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ID = ++totalNumber; <span class="comment">// 可在构造器中给final修饰的“变量”赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    System.out.println(t.ID);</span><br><span class="line">    t.ID = <span class="number">1</span>;<span class="comment">//非法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    x = <span class="number">20</span>;<span class="comment">//非法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line">    y = <span class="number">30</span>; <span class="comment">//合法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><blockquote>
<p>当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上 的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象， 其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少 对象的情况下，某些特定的数据在内存空间里只有一份，例如所有的中国人都有个 国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中 都单独分配一个用于代表国家名称的变量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">1.0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius=radius;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.PI*radius*radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建两个Circle对象</span></span><br><span class="line">Circle c1=<span class="keyword">new</span> Circle(<span class="number">2.0</span>); <span class="comment">//c1.radius=2.0</span></span><br><span class="line">Circle c2=<span class="keyword">new</span> Circle(<span class="number">3.0</span>); <span class="comment">//c2.radius=3.0</span></span><br></pre></td></tr></table></figure>

<p>上面的Circle类中的变量radius是一个<strong>实例变量(instance variable)</strong>，它属于类的每一个对象，不能被同一个类的不同对象所共享。上例中c1的radius独立于c2的radius，存储在不同的空间。c1中的radius 变化不会影响c2的radius，反之亦然。</p>
<ul>
<li><p>static关键字的使用范围： </p>
<ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
</li>
<li><p>被修饰后的成员具备以下特点：</p>
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可以不创建对象，直接被类调用</li>
</ul>
</li>
</ul>
<h3 id="静态变量（类变量）"><a href="#静态变量（类变量）" class="headerlink" title="静态变量（类变量）"></a>静态变量（类变量）</h3><p>类属性作为该类各个对象之间共享的变量。在设计类时,分析哪些属性不因对象的不同而改变，将这些属性设置为类属性。相应的方法设置为类方法。</p>
<p>拿上面的煮个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> radius = <span class="number">1.0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.PI*radius*radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建两个Circle对象</span></span><br><span class="line">Circle c1=<span class="keyword">new</span> Circle(); <span class="comment">//c1.radius=1.0</span></span><br><span class="line">Circle c2=<span class="keyword">new</span> Circle(); <span class="comment">//c2.radius=1.0</span></span><br><span class="line"><span class="comment">//这两个对象是共用这个radius，radius在内存空间中指向的是同一个地址</span></span><br></pre></td></tr></table></figure>

<p>再煮个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    total++;</span><br><span class="line">    id = total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;<span class="comment">//每次new对象的时候id会自动加1</span></span><br><span class="line">    total++;</span><br><span class="line">    id = total;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Person Tom = <span class="keyword">new</span> Person();</span><br><span class="line">    Tom.id=<span class="number">0</span>;</span><br><span class="line">    total=<span class="number">100</span>; <span class="comment">// 不用创建对象就可以访问静态成员</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Person.total = <span class="number">100</span>; <span class="comment">// 不用创建对象就可以访问静态成员</span></span><br><span class="line">    <span class="comment">//访问方式：类名.类属性，类名.类方法</span></span><br><span class="line">    System.out.println(Person.total);</span><br><span class="line">    Person c = <span class="keyword">new</span> Person();</span><br><span class="line">    System.out.println(c.total); <span class="comment">//输出101</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog.steventan.top/images/Java基础知识总结（下）/image-20200506143718368.png" alt="image-20200506143718368.png" style="zoom: 70%;" />



<h3 id="静态方法（类方法）"><a href="#静态方法（类方法）" class="headerlink" title="静态方法（类方法）"></a>静态方法（类方法）</h3><p>如果方法与调用者无关，则这样的方法通常被声明为类方法，由于不需要创建对象就可以调用类方法，从而简化了方法的调用。</p>
<ul>
<li><p>因为不需要实例就可以访问static方法，因此static方法内部不能有this。==(也不能有super )==</p>
</li>
<li><p>==static修饰的方法不能被重写==</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setTotalPerson</span><span class="params">(<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">this</span>.total=total; <span class="comment">//非法，在static方法中不能有this，也不能有super</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    total++;</span><br><span class="line">    id = total;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person.setTotalPerson(<span class="number">3</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例-Singleton-设计模式"><a href="#单例-Singleton-设计模式" class="headerlink" title="单例(Singleton)设计模式"></a>单例(Singleton)设计模式</h3><blockquote>
<p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、 以及解决问题的思考方式。设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。</p>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象， 静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p>
</blockquote>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">  <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton single = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> single;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>这种写法暂时还存在线程安全的问题，后面多线程的时候再修复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.私有化构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">  <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line">  <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(single == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	single = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><p>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的 产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>网站的计数器，一般是单例模式实现，否则难以同步</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
</ul>
<h3 id="main方法的理解"><a href="#main方法的理解" class="headerlink" title="main方法的理解"></a>main方法的理解</h3><blockquote>
<p>由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是 public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须 是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令 时传递给所运行的类的参数。</p>
<p>又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创 建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情 况，我们在之前的例子中多次碰到。</p>
</blockquote>
<h4 id="命令行参数用法举例"><a href="#命令行参数用法举例" class="headerlink" title="命令行参数用法举例"></a>命令行参数用法举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPara</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"args["</span> + i + <span class="string">"] = "</span> + args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行程序CommandPara.java</span></span><br><span class="line"><span class="comment">//java CommandPara “Tom" “Jerry" “John"</span></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//args[0] = Tom</span></span><br><span class="line"><span class="comment">//args[1] = Jerry</span></span><br><span class="line"><span class="comment">//args[2] = John</span></span><br></pre></td></tr></table></figure>



<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对Java类或对象进行初始化</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="comment">//属性......</span></span><br><span class="line">  <span class="comment">//代码块</span></span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构造器......</span></span><br><span class="line">  <span class="comment">//方法......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><p>不可以调用非静态的属性和方法。</p>
</li>
<li><p>静态代码块的执行要先于非静态代码块。</p>
</li>
<li><p>静态代码块随着类的加载而加载，并且只执行一次。</p>
</li>
</ol>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    total = <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">"in static block!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"total = "</span> + Person.total);<span class="comment">//100</span></span><br><span class="line">    System.out.println(<span class="string">"total = "</span> + Person.total);<span class="comment">//100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h3><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="comment">//属性.......</span></span><br><span class="line">  <span class="comment">//代码块</span></span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构造器.......</span></span><br><span class="line">  <span class="comment">//方法......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>可以调用静态的代码结构，也可以调用非静态的结构。</li>
<li>每次创建对象的时候都会执行一次，且先于构造器的执行。</li>
</ol>
<h3 id="总结：程序中成员变量赋值的执行顺序"><a href="#总结：程序中成员变量赋值的执行顺序" class="headerlink" title="总结：程序中成员变量赋值的执行顺序"></a>总结：程序中成员变量赋值的执行顺序</h3><pre class="mermaid">graph TB
a(默认初始化) --> b(显示初始化)
a(默认初始化) --> c(代码块)
b --> d(构造器)
c --> d
d --> e(通过 对象.属性 或 对象.方法 给属性赋值)</pre>



<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><blockquote>
<p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。</p>
<p>内部类一般用在定义它的类或语句块之内，在外部引用它时必须给出完 整的名称。</p>
</blockquote>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul>
<li><p>内部类作为类的成员的角色：</p>
<ul>
<li>和外部类不同，内部类还可以声明为private或protected</li>
<li>可以调用外部类的结构</li>
<li>内部类可以声明为static的，但此时就不能再使用外层类的非static的成员变量</li>
</ul>
</li>
<li><p>内部类作为类的角色：</p>
<ul>
<li>可以在内部定义属性、方法、构造器等结构</li>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
<li>可以声明为final的</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。</li>
<li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</li>
<li>成员内部类可以直接使用外部类的所有成员，包括私有的数据</li>
<li>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</li>
</ol>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> s = <span class="number">111</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s = <span class="number">222</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mb</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">      System.out.println(s); <span class="comment">// 局部变量s</span></span><br><span class="line">      System.out.println(<span class="keyword">this</span>.s); <span class="comment">// 内部类对象的属性s</span></span><br><span class="line">      System.out.println(Outer.<span class="keyword">this</span>.s); <span class="comment">// 外部类对象属性s</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Outer a = <span class="keyword">new</span> Outer();</span><br><span class="line">    Outer.Inner b = a.<span class="keyword">new</span> Inner();</span><br><span class="line">    b.mb(<span class="number">333</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类</span>&#123;</span><br><span class="line">  方法()&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> 局部内部类</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> 局部内部类</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类</li>
<li>是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型</li>
</ol>
<p>局部内部类的特点</p>
<ul>
<li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。 </li>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。 </li>
<li>局部内部类可以使用外部类的成员，包括私有的。 </li>
<li>局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。 </li>
<li>局部内部类和局部变量地位类似，不能使用public,protected,缺省,private </li>
<li>局部内部类不能使用static修饰，因此也不能包含静态成员</li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或 实现一个类。</p>
<p><strong>特点：</strong></p>
<ul>
<li>匿名内部类必须继承父类或实现接口 </li>
<li>匿名内部类只能有一个对象 </li>
<li>匿名内部类对象只能使用多态形式引用</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Outer().callInner(<span class="keyword">new</span> A()&#123;</span><br><span class="line">      <span class="comment">//接口是不能new但此处比较特殊是子类对象实现接口，只不过没有为对象取名</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“implement <span class="keyword">for</span> fun1<span class="string">");</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;);// 两步写成一步了</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	public void callInner(A a) &#123;</span></span><br><span class="line"><span class="string">		a.fun1();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>思考题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Inner s1 = <span class="keyword">new</span> Inner();</span><br><span class="line">    s1.a = <span class="number">10</span>;</span><br><span class="line">    Inner s2 = <span class="keyword">new</span> Inner();</span><br><span class="line">    s2.a = <span class="number">20</span>;</span><br><span class="line">    Test.Inner s3 = <span class="keyword">new</span> Test.Inner();</span><br><span class="line">    System.out.println(s3.a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    Inner r = t.<span class="keyword">new</span> Inner();</span><br><span class="line">    System.out.println(r.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是两个5</p>
<p>没想到吧，其实仔细看一下也不能理解</p>
<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><blockquote>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一 般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父 类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
</blockquote>
<p>先煮个栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  <span class="comment">//抽象类</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;  <span class="comment">//抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"A类中定义的m2方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;<span class="comment">//抽象方法的具体实现</span></span><br><span class="line">  	System.out.println(<span class="string">"B类中定义的m1方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> B();</span><br><span class="line">    a.m1();<span class="comment">//虚拟方法调用</span></span><br><span class="line">    a.m2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类的一些规定"><a href="#抽象类的一些规定" class="headerlink" title="抽象类的一些规定"></a>抽象类的一些规定</h3><ul>
<li>用abstract关键字来修饰一个类，这个类叫做抽象类。</li>
<li>用abstract来修饰一个方法，该方法叫做抽象方法。<ul>
<li>抽象方法：只有方法的声明，没有方法的实现，以分号结束： 比如：public abstract void talk();</li>
</ul>
</li>
<li>含有抽象方法的类必须被声明为抽象类。</li>
<li>抽象类==不能被实例化==。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写==全部==的抽象方法，则该类仍为抽象类。</li>
<li>抽象类可以有构造器，但是不能直接用构造器实例化对象，但实例化子类的时候，就会初始化父类，不管父类是不是抽象类都会调用父类的构造方法，初始化一个类，都要先先初始化父类。</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>不能用abstract修饰变量、代码块、构造器；</li>
<li>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</li>
</ol>
<h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3><blockquote>
<p>在航运公司系统中，Vehicle类需要定义两个方法分别计算运 输工具的燃料效率和行驶距离。</p>
<p>问题：卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不 同。Vehicle类不能提供计算方法，但子类可以。</p>
</blockquote>
<p>具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calcFuelEfficiency</span><span class="params">()</span></span>; <span class="comment">//计算燃料效率的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calcTripDistance</span><span class="params">()</span></span>; <span class="comment">//计算行驶距离的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcFuelEfficiency</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//写出计算卡车的燃料效率的具体方法 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcTripDistance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//写出计算卡车行驶距离的具体方法 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RiverBarge</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcFuelEfficiency</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//写出计算驳船的燃料效率的具体方法 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcTripDistance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//写出计算驳船行驶距离的具体方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：抽象类不能实例化 new Vihicle()是非法的!</strong></p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><blockquote>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
</blockquote>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用， 这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    code();</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"执行时间是："</span> + (end - start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方 法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
<li>另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又 没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打 印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都 支持USB连接。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则 必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。</li>
<li>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都 要遵守。</li>
</ol>
<img src="https://blog.steventan.top/images/Java基础知识总结（下）/image-20200506191958389.png" alt="image-20200506191958389" style="zoom:67%;" />

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><ul>
<li><strong>接口中所有成员变量都默认是public static final修饰的</strong></li>
<li><strong>接口中所有抽象方法都是public abstract修饰的</strong></li>
<li>接口中没有构造器</li>
<li>接口可以被多实现</li>
</ul>
<p>上面示例的代码实际上是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runner</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 准备工作：弯腰、蹬腿、咬牙、瞪眼</span></span><br><span class="line">    <span class="comment">// 开跑</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 摆动手臂</span></span><br><span class="line">    <span class="comment">// 维持直线方向</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 减速直至停止、喝水。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>一个类可以实现多个接口，接口也可以继承其它接口。</li>
<li>实现接口的类中必须提供接口中所有方法的具体实现，方可实例化。否则，仍为抽象类，不可实例化。</li>
<li>与继承关系类似，接口与实现类之间存在多态性</li>
<li>接口和类是并列关系，或者可以理解为一种特殊的类。从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义(JDK7.0及之前)，而没有变量和方法的实现。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Swimmer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Creator</span> <span class="keyword">implements</span> <span class="title">Runner</span>, <span class="title">Swimmer</span></span>&#123;<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类必须给出接口以及父接口中所有方法的实现。否则，实现类仍需声明为abstract的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">  String s=“MyInterface”;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">absM1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubInterface</span> <span class="keyword">extends</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">absM2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubAdapter</span> <span class="keyword">implements</span> <span class="title">SubInterface</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">absM1</span><span class="params">()</span></span>&#123;System.out.println(“absM1”);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">absM2</span><span class="params">()</span></span>&#123;System.out.println(“absM2”);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-8中关于接口的改进"><a href="#Java-8中关于接口的改进" class="headerlink" title="Java 8中关于接口的改进"></a>Java 8中关于接口的改进</h3><p>Java 8中，你可以为接口添加静态方法和默认方法。从技术角度来说，这是完 全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p>
<h4 id="静态方法："><a href="#静态方法：" class="headerlink" title="静态方法："></a>静态方法：</h4><p>使用 static 关键字修饰。可以通过接口直接调用静态方法，并执行 其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中 找到像Collection/Collections或者Path/Paths这样成对的接口和类。 </p>
<h4 id="默认方法："><a href="#默认方法：" class="headerlink" title="默认方法："></a>默认方法：</h4><p>默认方法使用 default 关键字修饰。可以通过实现类对象来调用。 我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。 比如：java 8 API中对Collection、List、Comparator等接口提供了丰富的默认 方法。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;<span class="comment">//默认方法</span></span><br><span class="line">    System.out.println(<span class="string">"北京"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"上海"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;<span class="comment">//静态方法</span></span><br><span class="line">    System.out.println(“hello lambda!<span class="string">");</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的方法（不管此方法是否是默认方法），在实现类同时实现了这两个接口时，会出现：接口冲突。</p>
</li>
<li><p>若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有相同名称和参数的默认方法会被忽略。</p>
</li>
</ul>
<p>煮个有趣的栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filial</span> </span>&#123;<span class="comment">// 孝顺的</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"老妈，我来救你了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Spoony</span> </span>&#123;<span class="comment">// 痴情的</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"媳妇，别怕，我来了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Filial</span>, <span class="title">Spoony</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我该怎么办呢？"</span>);</span><br><span class="line">    Filial.<span class="keyword">super</span>.help();</span><br><span class="line">    Spoony.<span class="keyword">super</span>.help();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h4><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealServer</span> <span class="keyword">implements</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"真实服务器上网浏览信息"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Network network;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(Network network)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.network = network;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"检查网络连接等操作"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check();</span><br><span class="line">    network.browse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Network net = <span class="keyword">new</span> ProxyServer(<span class="keyword">new</span> RealServer());</span><br><span class="line">    net.browse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>安全代理：屏蔽对真实角色的直接访问。</li>
<li>远程代理：通过代理类处理远程方法调用（RMI）</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理 模式，当需要查看图片时，用proxy来进行大图片的打开。</li>
</ol>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>略……..</p>
<h3 id="接口和抽象类之间的对比"><a href="#接口和抽象类之间的对比" class="headerlink" title="接口和抽象类之间的对比"></a>接口和抽象类之间的对比</h3><table>
<thead>
<tr>
<th align="left">区别点</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义</td>
<td>包含抽象方法的类</td>
<td>主要是抽象方法和全局常量的集合</td>
</tr>
<tr>
<td align="left">组成</td>
<td>构造器、抽象方法、普通方法、常量、变量</td>
<td>常量、抽象方法、（jdk8.0之后：默认方法、静态方法）</td>
</tr>
<tr>
<td align="left">使用</td>
<td>子类继承抽象类（extends）</td>
<td>子类实现接口（implements）</td>
</tr>
<tr>
<td align="left">关系</td>
<td>抽象类可以实现多个接口</td>
<td>接口不能继承抽象类，但接口可以继承接口</td>
</tr>
<tr>
<td align="left">局限</td>
<td>只能单继承</td>
<td>可以多实现</td>
</tr>
<tr>
<td align="left">实际</td>
<td>作为一个模板</td>
<td>作为一种标准或是表示一种能力</td>
</tr>
<tr>
<td align="left">常见设计模式</td>
<td>模板方法</td>
<td>工厂设计模式、代理模式</td>
</tr>
</tbody></table>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><blockquote>
<p>在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美， 在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避 免的，比如：客户输入数据的格式，读取文件是否存在，网络是否始终保持 通畅等等。</p>
</blockquote>
<p>Java程序在执行过程中所发生的异常事件可分为两大类：</p>
<ul>
<li>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError。一般不会编写针对性的代码进行处理。</li>
<li>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使 用针对性的代码进行处理。例如：<ul>
<li>空指针异常</li>
<li>读取的文件不存在</li>
<li>网络连接中断</li>
<li>数据角标越界</li>
</ul>
</li>
</ul>
<p>对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。</p>
<p>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等。</p>
<p>这里又可以将异常分为两类：分别是<strong>编译时异常</strong>和<strong>运行时异常</strong>。</p>
<img src="https://blog.steventan.top/images/Java基础知识总结（下）/image-20200512121258745.png" alt="image-20200512121258745" style="zoom: 80%;" />

<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。</p>
<p>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p>
<h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</p>
<p>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p>
<h3 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h3><h4 id="java-lang-RuntimeException"><a href="#java-lang-RuntimeException" class="headerlink" title="java.lang.RuntimeException"></a>java.lang.RuntimeException</h4><ol>
<li><p>ClassCastException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">    Order order;</span><br><span class="line">    order = (Order) obj;</span><br><span class="line">    System.out.println(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>ArrayIndexOutOfBoundsException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexOutExp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String friends[] = &#123; <span class="string">"lisa"</span>, <span class="string">"bily"</span>, <span class="string">"kessy"</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      System.out.println(friends[i]); <span class="comment">// friends[4]?</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"/nthis is the end"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>NullPointerException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullRef</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    NullRef t = <span class="keyword">new</span> NullRef();</span><br><span class="line">    t = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(t.i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>ArithmeticException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivideZero</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    DivideZero c=<span class="keyword">new</span> DivideZero();</span><br><span class="line">    y=<span class="number">3</span>/c.x;</span><br><span class="line">    System.out.println(<span class="string">"program ends ok!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>NumberFormatException</p>
</li>
<li><p>InputMismatchException</p>
</li>
<li><p>……</p>
</li>
</ol>
<h4 id="java-io-IOExeption"><a href="#java-io-IOExeption" class="headerlink" title="java.io.IOExeption"></a>java.io.IOExeption</h4><ol>
<li>FileNotFoundException</li>
<li>EOFException</li>
</ol>
<h4 id="java-lang-ClassNotFoundException"><a href="#java-lang-ClassNotFoundException" class="headerlink" title="java.lang.ClassNotFoundException"></a>java.lang.ClassNotFoundException</h4><h4 id="java-lang-InterruptedException"><a href="#java-lang-InterruptedException" class="headerlink" title="java.lang.InterruptedException"></a>java.lang.InterruptedException</h4><h4 id="java-io-FileNotFoundException"><a href="#java-io-FileNotFoundException" class="headerlink" title="java.io.FileNotFoundException"></a>java.io.FileNotFoundException</h4><h4 id="java-sql-SQLException"><a href="#java-sql-SQLException" class="headerlink" title="java.sql.SQLException"></a>java.sql.SQLException</h4><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><blockquote>
<p>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的if-else分支会导致程序的代码加长、臃肿，可读性差。因此采用异常处理机制。</p>
</blockquote>
<h4 id="机制一：try-catch-finally"><a href="#机制一：try-catch-finally" class="headerlink" title="机制一：try-catch-finally"></a>机制一：try-catch-finally</h4><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  ...... <span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName1 e )&#123;</span><br><span class="line">  ...... <span class="comment">//当产生ExceptionName1型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName2 e )&#123;</span><br><span class="line">  ...... <span class="comment">//当产生ExceptionName2型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">  ...... <span class="comment">//无论是否发生异常，都无条件执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>try </p>
<p>捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。</p>
</li>
<li><p>catch (Exceptiontype e)</p>
<p>在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
</li>
<li><p>finally</p>
<p>捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。</p>
</li>
</ul>
<p>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。 </p>
<p>比 如 ： 可以用ArithmeticException 类作为参数的地方，就可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，比如：NullPointerException（catch 中的语句将不会执行）。</p>
<p>捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。</p>
<ul>
<li><p>getMessage() 获取异常信息，返回字符串 </p>
</li>
<li><p>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</p>
</li>
</ul>
<img src="https://blog.steventan.top/images/Java基础知识总结（下）/image-20200512201503354.png" alt="image-20200512201503354" style="zoom:80%;" />

<h4 id="常见异常捕获的举例"><a href="#常见异常捕获的举例" class="headerlink" title="常见异常捕获的举例"></a>常见异常捕获的举例</h4><h5 id="数据角标越界"><a href="#数据角标越界" class="headerlink" title="数据角标越界"></a>数据角标越界</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexOutExp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String friends[] = &#123; <span class="string">"lisa"</span>, <span class="string">"bily"</span>, <span class="string">"kessy"</span> &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        System.out.println(friends[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"index err"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"/nthis is the end"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//lisa</span></span><br><span class="line"><span class="comment">//bily</span></span><br><span class="line"><span class="comment">//kessy</span></span><br><span class="line"><span class="comment">//index err</span></span><br><span class="line"><span class="comment">//this is the end</span></span><br></pre></td></tr></table></figure>

<h5 id="除零异常"><a href="#除零异常" class="headerlink" title="除零异常"></a>除零异常</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivideZero1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    DivideZero1 c = <span class="keyword">new</span> DivideZero1();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      y = <span class="number">3</span> / c.x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"divide by zero error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"program ends ok!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//divide by zero error!</span></span><br><span class="line"><span class="comment">//program ends ok!</span></span><br></pre></td></tr></table></figure>

<h4 id="不捕获异常时的情况"><a href="#不捕获异常时的情况" class="headerlink" title="不捕获异常时的情况"></a>不捕获异常时的情况</h4><p>前面使用的异常都是RuntimeException类或是它的子类，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过( <strong>但运行时会发生异常使得程序运行终止</strong> )。</p>
<p>如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。</p>
<h4 id="机制二：throws"><a href="#机制二：throws" class="headerlink" title="机制二：throws"></a>机制二：throws</h4><p>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这 种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理， 而由该方法的<strong>调用者</strong>负责处理。</p>
<p>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>
<h5 id="声明抛出异常举例："><a href="#声明抛出异常举例：" class="headerlink" title="声明抛出异常举例："></a>声明抛出异常举例：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">  ……</span><br><span class="line">    <span class="comment">// 读文件的操作可能产生FileNotFoundException类型的异常</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">  ..……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThrowsTest t = <span class="keyword">new</span> ThrowsTest();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t.readFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"atguigushk.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    b = in.read();</span><br><span class="line">    <span class="keyword">while</span> (b != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">      b = in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog.steventan.top/images/Java基础知识总结（下）/image-20200512203407744.png" alt="image-20200512203407744" style="zoom:80%;" />

<h5 id="重写方法声明抛出异常的原则"><a href="#重写方法声明抛出异常的原则" class="headerlink" title="重写方法声明抛出异常的原则"></a>重写方法声明抛出异常的原则</h5><p><strong>重写方法不能抛出比被重写方法范围更大的异常类型</strong>。在多态的情况下，对methodA()方法的调用-异常的捕获按父类声明的异常处理。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//报错</span></span><br><span class="line">    ……</span><br><span class="line">  &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h3><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。</p>
<p>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IOException e = <span class="keyword">new</span> IOException();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>

<p>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将 会产生语法错误：</p>
<p>==throw new String(“want to throw”);==</p>
<h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><ul>
<li><p>一般地，用户自定义异常类都是RuntimeException的子类。 </p>
</li>
<li><p>自定义异常类通常需要编写几个重载的构造器。 </p>
</li>
<li><p>自定义异常需要提供serialVersionUID </p>
</li>
<li><p>自定义的异常通过throw抛出。 </p>
</li>
<li><p>自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。</p>
</li>
</ul>
<p>用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">13465653435L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> idnumber;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">    <span class="keyword">this</span>.idnumber = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> idnumber;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExpTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"人数为负值，不合理"</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">"登记人数"</span> + num);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      regist(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">      System.out.print(<span class="string">"登记失败，出错种类"</span> + e.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">"本次登记操作结束"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    MyExpTest t = <span class="keyword">new</span> MyExpTest();</span><br><span class="line">    t.manager();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog.steventan.top/images/Java基础知识总结（下）/image-20200512204401486.png" alt="image-20200512204401486" style="zoom: 67%;" />]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java标识符命名规范</title>
    <url>/2020/03/28/Java%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<ol>
<li>包名：多单词组合时多有字母都小写，例如：helloworld</li>
<li>类名和接口名：多单词组合所有单词第一个字母大写，例如：HelloWorld</li>
<li>变量名和方法名：多单词组合时，除了第一个单词其他单词的第一个字母大写，例如：helloWorld</li>
<li>常量名：所有字母都大写，多单词组合时下划线连接，例如：HELLO_WORLD</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识总结（中）</title>
    <url>/2020/04/15/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<h2 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h2><ul>
<li><p>面向过程(POP) 与 面向对象(OOP)</p>
<ul>
<li><p>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的 是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对 象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</p>
</li>
<li><p>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如 抽象、分类、继承、聚合、多态等。</p>
<p><em>面向对象：Object Oriented Programming</em> </p>
<p><em>面向过程：Procedure Oriented Programming</em></p>
</li>
</ul>
</li>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装（Encapsulation）</li>
<li>继承（Inheritance）</li>
<li>多态（Polymorphism）</li>
</ul>
<a id="more"></a>

</li>
</ul>
<p>煮个栗子：</p>
<img src="https://blog.steventan.top/images/Java基础知识总结（中）/YxauQKcO3TyLqmM.png" alt="image.png" style="zoom: 67%;" />

<!--more-->

<h2 id="Java中的基本元素：类和对象"><a href="#Java中的基本元素：类和对象" class="headerlink" title="Java中的基本元素：类和对象"></a>Java中的基本元素：类和对象</h2><h3 id="类的语法格式"><a href="#类的语法格式" class="headerlink" title="类的语法格式"></a>类的语法格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">  属性声明;</span><br><span class="line">  方法申明;</span><br><span class="line">&#125;</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age ; <span class="comment">//声明私有变量 age</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//声明方法showAge( )</span></span><br><span class="line">  	age = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h3><ul>
<li>创建对象语法：类名 对象名 = new 类名();</li>
<li>用“对象名.对象成员”的方式就能访问对象成员</li>
</ul>
<p>内存解析：<img src="https://blog.steventan.top/images/Java基础知识总结（中）/JD1uqrjePf5HURc.png" alt="image.png" style="zoom: 67%;" /></p>
<h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这 样的对象叫做匿名对象。 </p>
<p>如：new Person().shout(); </p>
<p>使用情况：如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 我们经常将匿名对象作为实参传递给一个方法调用。</p>
<h3 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h3><h4 id="属性（field）"><a href="#属性（field）" class="headerlink" title="属性（field）"></a>属性（field）</h4><h5 id="语法格式：-修饰符-数据类型-属性名-初始化值"><a href="#语法格式：-修饰符-数据类型-属性名-初始化值" class="headerlink" title="语法格式： 修饰符 数据类型 属性名 = 初始化值 ;"></a>语法格式： 修饰符 数据类型 属性名 = 初始化值 ;</h5><ul>
<li>说明1: 修饰符 <ul>
<li>常用的权限修饰符有：private、缺省、protected、public </li>
<li>其他修饰符：static、final (暂不考虑) </li>
</ul>
</li>
<li>说明2：数据类型 <ul>
<li>任何基本数据类型(如int、Boolean) 或 任何引用数据类型。 </li>
</ul>
</li>
<li>说明3：属性名 <ul>
<li>属于标识符，符合命名规则和规范即可。 </li>
</ul>
</li>
</ul>
<p>举例： public class Person{ private int age; //声明private变量 age public String name = “Lila”; //声明public变量 name }</p>
<h5 id="变量的分类（成员变量和局部变量）"><a href="#变量的分类（成员变量和局部变量）" class="headerlink" title="变量的分类（成员变量和局部变量）"></a>变量的分类（成员变量和局部变量）</h5><ul>
<li>在方法体外，类体内声明的变量称为成员变量。 </li>
<li>在方法体内部声明的变量称为局部变量。</li>
</ul>
<p>成员变量和局部变量区别：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">成员变量</th>
<th align="center">局部变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">声明的位置</td>
<td align="center">直接声明在类型中</td>
<td align="center">方法内部、代码块内、构造器内</td>
</tr>
<tr>
<td align="center">修饰符</td>
<td align="center">private、public、static等</td>
<td align="center">不能用权限修饰符，可以用final修饰</td>
</tr>
<tr>
<td align="center">初始化值</td>
<td align="center">有默认初始化值</td>
<td align="center">没有默认初始化值，必须要显示赋值</td>
</tr>
<tr>
<td align="center">内存加载位置</td>
<td align="center">堆空间或静态域内</td>
<td align="center">栈空间</td>
</tr>
</tbody></table>
<h4 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h4><h5 id="方法的声明格式："><a href="#方法的声明格式：" class="headerlink" title="方法的声明格式："></a>方法的声明格式：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 形参<span class="number">1</span>, 参数类型 形参<span class="number">2</span>, ….）｛</span><br><span class="line">  方法体程序代码</span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>其中： 修饰符：public,缺省,private, protected等 返回值类型：</p>
<ul>
<li>没有返回值：void。 </li>
<li>有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用 方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意” 形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开 返回值：方法在执行完毕后返还给调用它的程序的数据。</li>
</ul>
<h5 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h5><img src="https://blog.steventan.top/images/Java基础知识总结（中）/sSNBGoyAzTU2xbp.png" alt="image.png" style="zoom: 67%;" />

<h5 id="方法的重载（overload）"><a href="#方法的重载（overload）" class="headerlink" title="方法的重载（overload）"></a>方法的重载（overload）</h5><p>1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的<strong>参数个数</strong>或者<strong>参数类型</strong>不同即可。</p>
<ul>
<li><p>“两同一不同”:同一个类、相同方法名</p>
</li>
<li><p>参数列表不同：参数个数不同，参数类型不同</p>
</li>
</ul>
<p>使用重载方法，可以为编程带来方便。 </p>
<p>例如，System.out.println()方法就是典型的重载方法，其内部的声 明形式如下： </p>
<p>public void println(byte x) </p>
<p>public void println(short x) </p>
<p>public void println(int x) </p>
<p>public void println(long x) </p>
<p>public void println(float x) </p>
<p>public void println(double x) </p>
<p>public void println(char x) </p>
<p>public void println(double x) </p>
<p>public void println()</p>
<p>……</p>
<h5 id="可变个数的形参"><a href="#可变个数的形参" class="headerlink" title="可变个数的形参"></a>可变个数的形参</h5><p>1.JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定 义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a ,String[] books)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a ,String … books)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.具体使用：</p>
<ul>
<li><p>2.1 可变个数形参的格式：数据类型 … 变量名</p>
</li>
<li><p>2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</p>
</li>
<li><p>2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p>
</li>
<li><p>2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</p>
</li>
<li><p>2.5 可变个数形参在方法的形参中，必须声明在末尾</p>
</li>
<li><p>2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String[] msg)</span></span>&#123;</span><br><span class="line">  System.out.println(“含字符串数组参数的test方法 <span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">public void test1(String book)&#123;</span></span><br><span class="line"><span class="string">	System.out.println(“****与可变形参方法构成重载的test1方法****"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String ... books)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"****形参长度可变的test1方法****"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">TestOverload to = <span class="keyword">new</span> TestOverload();</span><br><span class="line">  <span class="comment">//下面两次调用将执行第二个test方法</span></span><br><span class="line">  to.test1();</span><br><span class="line">  to.test1(<span class="string">"aa"</span> , <span class="string">"bb"</span>);</span><br><span class="line">  <span class="comment">//下面将执行第一个test方法</span></span><br><span class="line">  to.test(<span class="keyword">new</span> String[]&#123;<span class="string">"aa"</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h5><p>方法，必须由其所在类或对象调用才有意义。若方法含有参数： </p>
<ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传给形参的参数值</li>
</ul>
<p>Java的实参值如何传入方法呢？</p>
<p>Java里方法的参数传递方式只有一种：<strong>值传递</strong>。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。</p>
<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“<strong>数据值</strong>”传递给形参 </li>
<li>形参是引用数据类型：将实参引用数据类型变量的“<strong>地址值</strong>”传递给形参</li>
</ul>
<img src="https://blog.steventan.top/images/Java基础知识总结（中）/RuJgS4FkPxGONo2.png" alt="image.png" style="zoom: 80%;" />

<img src="https://blog.steventan.top/images/Java基础知识总结（中）/FoCkBhuLtl5Vyjf.png" alt="image.png" style="zoom: 80%;" />

<img src="https://blog.steventan.top/images/Java基础知识总结（中）/1zWEMB2Iki7o6my.png" alt="image.png" style="zoom:80%;" />

<img src="https://blog.steventan.top/images/Java基础知识总结（中）/2ARmBoaSXKpV5Zr.png" alt="image.png" style="zoom:80%;" />

<img src="https://blog.steventan.top/images/Java基础知识总结（中）/XCNFBZkxrmYtuJP.png" alt="image.png" style="zoom:80%;" />

<p><img src="https://blog.steventan.top/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/PHC8ReFzDhMfXwj.png" alt=""></p>
<p><img src="https://blog.steventan.top/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/DHXK67YzpVJeOEm.webp" alt=""></p>
<h4 id="构造器（构造方法）"><a href="#构造器（构造方法）" class="headerlink" title="构造器（构造方法）"></a>构造器（构造方法）</h4><h5 id="构造器的特征"><a href="#构造器的特征" class="headerlink" title="构造器的特征"></a>构造器的特征</h5><ul>
<li>它具有与类相同的名称 </li>
<li>它不声明返回值类型。（与声明为void不同） </li>
<li>不能被static、final、synchronized、abstract、native修饰，不能有 return语句返回值</li>
</ul>
<h5 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a>构造器的作用</h5><ul>
<li>创建对象</li>
<li>给对象进行初始化</li>
</ul>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>根据参数不同，构造器可以分为如下两类： </p>
<ul>
<li>隐式无参构造器（系统默认提供） </li>
<li>显式定义一个或多个构造器（无参、有参）</li>
</ul>
<p>注意：</p>
<ol>
<li>Java语言中，每个类都至少有一个构造器 </li>
<li>默认构造器的修饰符与所属类的修饰符一致 </li>
<li>一旦显式定义了构造器，则系统不再提供默认构造器 </li>
<li>一个类可以创建多个重载的构造器 </li>
<li>父类的构造器不可被子类继承</li>
</ol>
<h5 id="构造器的重载"><a href="#构造器的重载" class="headerlink" title="构造器的重载"></a>构造器的重载</h5><p>构造器重载，参数列表必须不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;<span class="keyword">this</span>(name,age);…&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;…&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Date d)</span> </span>&#123;…&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>JavaBean是一种Java语言写成的可重用组件。</p>
<p>所谓javaBean，是指符合如下标准的Java类： </p>
<ul>
<li>类是公共的 </li>
<li>有一个无参的公共的构造器 </li>
<li>有属性，且有对应的get、set方法</li>
</ul>
<p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以 用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP 页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用 户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关 心任何改变。</p>
<h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><img src="https://blog.steventan.top/images/Java基础知识总结（中）/hDmlsInjw7HBKuN.png" alt="image.png" style="zoom:80%;" />



<h2 id="面向对象的特征之一：封装"><a href="#面向对象的特征之一：封装" class="headerlink" title="面向对象的特征之一：封装"></a>面向对象的特征之一：封装</h2><h3 id="为什么需要封装？"><a href="#为什么需要封装？" class="headerlink" title="为什么需要封装？"></a>为什么需要封装？</h3><ul>
<li><p>封装的作用和含义？</p>
<ul>
<li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内 部的结构吗？有必要碰电动机吗？ </li>
<li>我要开车，… </li>
</ul>
</li>
<li><p>我们程序设计追求“高内聚，低耦合”。 </p>
<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； </li>
<li>低耦合 ：仅对外暴露少量的方法用于使用。 </li>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提 高系统的可扩展性、可维护性。通俗的说，<strong>把该隐藏的隐藏起来，该暴露的暴露出来</strong>。这就是封装性的设计思想。</li>
</ul>
</li>
</ul>
<p>使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或安全性问题</p>
<p>应该将legs属性保护起来， 防止乱用。 </p>
<p>保护的方式：信息隐藏</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> legs;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"Eating"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"Moving."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Animal xb = <span class="keyword">new</span> Animal();</span><br><span class="line">    xb.legs = <span class="number">4</span>;</span><br><span class="line">    System.out.println(xb.legs);</span><br><span class="line">    xb.eat();</span><br><span class="line">    xb.move();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中通过将数据声明为私有的(private)，再提供公共的（public） 方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的： </p>
<ul>
<li>隐藏一个类中不需要对外提供的实现细节； </li>
<li>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑， 限制对属性的不合理操作；</li>
<li>便于修改，增强代码的可维护性；</li>
</ul>
<h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">内部类</th>
<th align="center">同一个包</th>
<th align="center">不同的子包</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">（缺省）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>对于class的权限修饰只可以用public和default(缺省)。 </p>
<ul>
<li>public类可以在任意地方被访问。 </li>
<li>default类只可以被同一个包内部的类访问。</li>
</ul>
<h3 id="关键字this的使用"><a href="#关键字this的使用" class="headerlink" title="关键字this的使用"></a>关键字this的使用</h3><h3 id="在Java中，this关键字比较难理解，它的作用和其词义很接近。"><a href="#在Java中，this关键字比较难理解，它的作用和其词义很接近。" class="headerlink" title="在Java中，this关键字比较难理解，它的作用和其词义很接近。"></a>在Java中，this关键字比较难理解，它的作用和其词义很接近。</h3><ul>
<li>它在方法内部使用，即这个方法所属对象的引用； </li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象</li>
</ul>
<h3 id="this-可以调用类的属性、方法和构造器"><a href="#this-可以调用类的属性、方法和构造器" class="headerlink" title="this 可以调用类的属性、方法和构造器"></a>this 可以调用类的属性、方法和构造器</h3><h3 id="什么时候可以用this关键字"><a href="#什么时候可以用this关键字" class="headerlink" title="什么时候可以用this关键字"></a>什么时候可以用this关键字</h3><p>当在方法内需要用到调用该方法的对象时，就用this。 具体的：我们可以用this来区分属性和局部变量。 比如：this.name = name;</p>
<p><strong>调用属性和方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">  <span class="keyword">private</span> String name ;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name ;</span><br><span class="line">    <span class="keyword">this</span>.age = age ; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"姓名："</span> + name) ;</span><br><span class="line">    <span class="keyword">this</span>.speak();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	System.out.println(“年龄：” + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当前正在操作本方法的对 象称为当前对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">  String name;</span><br><span class="line">  Person(String name)&#123;</span><br><span class="line">  	<span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"Person类 --&gt; "</span> + <span class="keyword">this</span>.name) ; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">this</span>.name==p.name;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Person per1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>) ;</span><br><span class="line">    Person per2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>) ;</span><br><span class="line">    per1.getInfo() ; <span class="comment">// 当前调用getInfo()方法的对象是per1</span></span><br><span class="line">    per2.getInfo() ; <span class="comment">// 当前调用getInfo()方法的对象是per2</span></span><br><span class="line">    <span class="keyword">boolean</span> b = per1.compare(per2);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">  <span class="keyword">private</span> String name ;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123; <span class="comment">// 无参构造器</span></span><br><span class="line">  	System.out.println(<span class="string">"新对象实例化"</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(); <span class="comment">// 调用本类中的无参构造器</span></span><br><span class="line">    <span class="keyword">this</span>.name = name ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name) ; <span class="comment">// 调用有一个参数的构造器</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="string">"姓名："</span> + name + <span class="string">"，年龄："</span> + age ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象的特征之二：继承"><a href="#面向对象的特征之二：继承" class="headerlink" title="面向对象的特征之二：继承"></a>面向对象的特征之二：继承</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> Date birthDate;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String school;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么要有继承？"><a href="#为什么要有继承？" class="headerlink" title="为什么要有继承？"></a>为什么要有继承？</h3><ul>
<li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中， 那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li>
</ul>
<ul>
<li><p>此处的多个类称为子类(派生类)，单独的这个类称为父类(基类 或超类)。可以理解为:“子类 is a 父类”</p>
</li>
<li><p>类继承语法规则: class Subclass extends SuperClass{ }</p>
</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。 </li>
<li>继承的出现，更有利于功能的扩展。 </li>
<li>继承的出现让类与类之间产生了关系，<strong>提供了多态的前提</strong>。</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p>子类继承了父类，就继承了父类的方法和属性，</p>
<p>但是子类不能直接访问父类中私有的(private)的成员变量和方法。</p>
</li>
<li><p>在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和 方法。 </p>
</li>
<li><p>在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集， 而是对父类的“扩展”。</p>
</li>
<li><p>Java只支持单继承和多层继承，不允许多重继承 </p>
</li>
<li><p>一个子类只能有一个父类 </p>
<ul>
<li>一个父类可以派生出多个子类 </li>
<li>class SubDemo extends Demo{ } //ok </li>
<li>class SubDemo extends Demo1,Demo2…//error</li>
</ul>
</li>
</ol>
<h3 id="方法的重写（override-overwrite）"><a href="#方法的重写（override-overwrite）" class="headerlink" title="方法的重写（override/overwrite）"></a>方法的重写（override/overwrite）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="string">"Name: "</span>+ name + <span class="string">"\n"</span> +<span class="string">"age: "</span>+ age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String school;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="comment">//重写方法</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="string">"Name: "</span>+ name + <span class="string">"\nage: "</span>+ age + <span class="string">"\nschool: "</span>+ school;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Student s1=<span class="keyword">new</span> Student();</span><br><span class="line">    s1.name=<span class="string">"Bob"</span>;</span><br><span class="line">    s1.age=<span class="number">20</span>;</span><br><span class="line">    s1.school=<span class="string">"school2"</span>;</span><br><span class="line">    System.out.println(s1.getInfo()); <span class="comment">//Name:Bob age:20 school:school2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在子类中可以根据需要对从父类中继承来的方法进行改造，也称 为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
<h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ol>
<li>子类重写的方法必须和父类被重写的方法具有<strong>相同的方法名称、参数列表</strong> </li>
<li>子类重写的方法的返回值类型<strong>不能大于</strong>父类被重写的方法的返回值类型 </li>
<li>子类重写的方法使用的访问权限<strong>不能小于</strong>父类被重写的方法的访问权限 <ul>
<li>子类不能重写父类中声明为private权限的方法 </li>
</ul>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
<h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ul>
<li><p><strong>在Java类中使用super来调用父类中的指定操作：</strong></p>
<ul>
<li>super可用于访问父类中定义的属性</li>
<li>super可用于调用父类中定义的成员方法 </li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员 </li>
<li>super的追溯不仅限于直接父类 </li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存 空间的标识</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> String name = <span class="string">"张三"</span>; </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Name: "</span> + name + <span class="string">"\nage: "</span> + age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> String name = <span class="string">"李四"</span>;</span><br><span class="line">   <span class="keyword">private</span> String school = <span class="string">"New Oriental"</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> school;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getInfo() + <span class="string">"\nschool: "</span> + school;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用父类的构造器"><a href="#调用父类的构造器" class="headerlink" title="调用父类的构造器"></a>调用父类的构造器</h4><ul>
<li>子类中所有的构造器默认都会访问父类中的<strong>空参构造器</strong> </li>
<li>当父类中没有空参构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的 构造器。同时，只能”二选一” ，且必须放在构造器的首行</li>
<li>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又 没有无参的构造器，则编译出错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> Date birthDate;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.birthDate = d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, age, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Date d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, <span class="number">30</span>, d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, <span class="number">30</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String school;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">    school = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    school = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s)</span> </span>&#123;<span class="comment">// 编译出错: no super(),系统将调用父类无参数的构造器。</span></span><br><span class="line">  	school = s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子类对象的实例化过程"><a href="#子类对象的实例化过程" class="headerlink" title="子类对象的实例化过程"></a>子类对象的实例化过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Creature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="string">"Creature无参数的构造器"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">Creature</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Animal带一个参数的构造器，该动物的name为"</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name);</span><br><span class="line">    System.out.println(<span class="string">"Animal带两个参数的构造器，其age为"</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wolf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">super</span>(<span class="string">"灰太狼"</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">"Wolf无参数的构造器"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">new</span> Wolf();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面向对象的特征之三：多态"><a href="#面向对象的特征之三：多态" class="headerlink" title="面向对象的特征之三：多态"></a>面向对象的特征之三：多态</h2><ul>
<li><p>多态性，是面向对象中最重要的概念，在Java中的体现</p>
<p>对象的多态性：父类的引用指向子类的对象 </p>
<ul>
<li>可以直接应用在抽象类和接口上</li>
</ul>
</li>
<li><p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简 称：编译时，看左边；运行时，看右边。 </p>
<ul>
<li><p>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) </p>
</li>
<li><p>多态情况下， “看左边” ：看的是父类的引用（父类中不具备子类特有的方法） </p>
<p>​                        “看右边” ：看的是子类的对象（实际运行的是子类重写父类的方法）</p>
</li>
</ul>
</li>
<li><p>对象的多态 —在Java中,子类的对象可以替代父类的对象使用 </p>
<ul>
<li>一个变量只能有一种确定的数据类型 </li>
<li>一个引用类型变量可能指向(引用)多种不同类型的对象</li>
</ul>
</li>
</ul>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>存在继承或者实现关系</li>
<li>有方法的重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">Object o = <span class="keyword">new</span> Person();<span class="comment">//Object类型的变量o，指向Person类型的对象</span></span><br><span class="line">o = <span class="keyword">new</span> Student(); <span class="comment">//Object类型的变量o，指向Student类型的对象</span></span><br></pre></td></tr></table></figure>

<p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向 上转型(upcasting)。</p>
<ul>
<li><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，</p>
<p>那么该变量就不能再访问子类中特有的属性</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student m = <span class="keyword">new</span> Student();</span><br><span class="line">m.school = “pku”; <span class="comment">//合法,Student类有school成员变量</span></span><br><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.school = “pku”; <span class="comment">//非法,Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>

<p><strong>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编 译错误。</strong></p>
<h3 id="虚拟方法调用"><a href="#虚拟方法调用" class="headerlink" title="虚拟方法调用"></a>虚拟方法调用</h3><p>正常的方法调用 :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Person();</span><br><span class="line">e.getInfo();</span><br><span class="line">Student e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo();</span><br></pre></td></tr></table></figure>

<p>虚拟方法调用(多态情况下) :</p>
<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父 类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法 确定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo(); <span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure>

<h3 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h3><p>x instanceof A：检验x是否为类A的对象，返回值为boolean型。</p>
<ul>
<li>要求x所属的类与类A<strong>必须是子类和父类的关系</strong>，否则编译错误</li>
<li>如果x属于类A的子类B，x instanceof A值也为true</li>
</ul>
<h3 id="对象类型转换（Casting）"><a href="#对象类型转换（Casting）" class="headerlink" title="对象类型转换（Casting）"></a>对象类型转换（Casting）</h3><p>基本数据类型的Casting：</p>
<ul>
<li>自动类型转换：小的数据类型可以自动转换成大的数据类型 <ul>
<li>如long g=20; double d=12.0f</li>
</ul>
</li>
<li>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型 <ul>
<li>如 float f=(float)12.0; int a=(int)1200L</li>
</ul>
</li>
</ul>
<p>对Java对象的强制类型转换称为造型 </p>
<ul>
<li><p>从子类到父类的类型转换可以自动进行 </p>
</li>
<li><p>从父类到子类的类型转换必须通过造型(强制类型转换)实现 </p>
</li>
<li><p>无继承关系的引用类型间的转换是非法的 </p>
</li>
<li><p>在造型前可以使用instanceof操作符测试一个对象的类型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConversionTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">13.4</span>;</span><br><span class="line">    <span class="keyword">long</span> l = (<span class="keyword">long</span>) d;<span class="comment">//基本数据类型的装换</span></span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="keyword">int</span> in = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// boolean b = (boolean)in;</span></span><br><span class="line">    Object obj = <span class="string">"Hello"</span>;</span><br><span class="line">    String objStr = (String) obj;</span><br><span class="line">    System.out.println(objStr);</span><br><span class="line">    Object objPri = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 所以下面代码运行时引发ClassCastException异常</span></span><br><span class="line">    String str = (String) objPri;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person e)</span> </span>&#123; <span class="comment">// 设Person类中没有getschool() 方法</span></span><br><span class="line">    <span class="comment">// System.out.pritnln(e.getschool()); //非法,编译时错误</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">      Student me = (Student) e; <span class="comment">// 将e强制转换为Student类型</span></span><br><span class="line">      System.out.pritnln(me.getschool());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    Student m = <span class="keyword">new</span> Student();</span><br><span class="line">    t.method(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="https://blog.steventan.top/images/Java基础知识总结（中）/KiTxoUjIpfJaCrN.png" alt="image.png" style="zoom:80%;" />

<p>继承成员变量和方法的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMethodTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">    System.out.println(s.count);<span class="comment">//20</span></span><br><span class="line">    s.display();<span class="comment">//20</span></span><br><span class="line">    Base b = s;</span><br><span class="line">    System.out.println(b == s);<span class="comment">//true</span></span><br><span class="line">    System.out.println(b.count);<span class="comment">//10</span></span><br><span class="line">    b.display();<span class="comment">//20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类继承父类</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法<strong>彻底覆盖了</strong>父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</li>
</ul>
<h3 id="Object类的使用"><a href="#Object类的使用" class="headerlink" title="Object类的使用"></a>Object类的使用</h3><ul>
<li>Object类是所有Java类的根父类</li>
<li>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">等价于：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object类中的主要结构</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public Object()</td>
<td align="left">构造器</td>
<td align="left">构造器</td>
</tr>
<tr>
<td align="left">public boolean equals(Object obj)</td>
<td align="left">方法</td>
<td align="left">对象比较</td>
</tr>
<tr>
<td align="left">public int hashCode()</td>
<td align="left">方法</td>
<td align="left">获取Hash码</td>
</tr>
<tr>
<td align="left">public Sting toString()</td>
<td align="left">方法</td>
<td align="left">打印对象的信息</td>
</tr>
</tbody></table>
<h4 id="和equals-方法"><a href="#和equals-方法" class="headerlink" title="==和equals()方法"></a>==和equals()方法</h4><ul>
<li>==<ul>
<li>基本类型比较值:只要两个变量的值相等，即为true。</li>
<li>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true</li>
</ul>
</li>
</ul>
<p><strong>用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本 数据类型除外)，否则编译出错</strong></p>
<ul>
<li><p>equals()方法</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。</p>
<p>只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。</p>
<p>格式:obj1.equals(obj2)</p>
</li>
<li><p>特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对 象； </p>
<p>原因：这些类型中重写了Object中的equals()方法</p>
</li>
<li><p>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等。</p>
</li>
</ul>
</li>
</ul>
<h5 id="和equals-的区别"><a href="#和equals-的区别" class="headerlink" title="==和equals()的区别"></a>==和equals()的区别</h5><ol>
<li>== 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址。</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==，String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性的值是否都相等</li>
</ol>
<h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h4><ul>
<li><p>toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在进行String与其它类型数据的连接操作时，自动调用toString()方法</p>
<p>Date now=new Date(); </p>
<p>System.out.println(“now=”+now); 相当于 </p>
<p>System.out.println(“now=”+now.toString());</p>
</li>
<li><p>可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法，返回字符串的值。</p>
</li>
</ul>
<h4 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h4><ul>
<li><p>针对八种基本数据类型定义相应的引用类型—包装类（封装类）</p>
</li>
<li><p>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Charater</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="基本数据类型包装成包装类的实例-—-gt-装箱"><a href="#基本数据类型包装成包装类的实例-—-gt-装箱" class="headerlink" title="基本数据类型包装成包装类的实例  —&gt;装箱"></a>基本数据类型包装成包装类的实例  —&gt;装箱</h5><ul>
<li><p>通过包装类的构造器实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">500</span>; </span><br><span class="line">Integer t = <span class="keyword">new</span> Integer(i);</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以通过字符串参数构造包装类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Float f = <span class="keyword">new</span> Float(“<span class="number">4.56</span>”); </span><br><span class="line">Long l = <span class="keyword">new</span> Long(“asdf”); <span class="comment">//NumberFormatException</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="获得包装类对象中包装的基本类型变量-—-gt-拆箱"><a href="#获得包装类对象中包装的基本类型变量-—-gt-拆箱" class="headerlink" title="获得包装类对象中包装的基本类型变量 —&gt;拆箱"></a>获得包装类对象中包装的基本类型变量 —&gt;拆箱</h5><ul>
<li><p>调用包装类的.xxxValue()方法：</p>
<p> boolean b = bObj.booleanValue();</p>
</li>
<li><p>JDK1.5之后，支持自动装箱，自动拆箱，但类型必须匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动装箱：基本数据类型 ---&gt;包装类</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">Integer in1 = num2;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">Boolean b2 = b1;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱：包装类---&gt;基本数据类型</span></span><br><span class="line">System.out.println(in1.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num3 = in1;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="字符串转换成基本数据类型"><a href="#字符串转换成基本数据类型" class="headerlink" title="字符串转换成基本数据类型"></a>字符串转换成基本数据类型</h5><ol>
<li>通过包装类的构造器实现： int i = new Integer(“12”);</li>
<li>通过包装类的parseXxx(String s)静态方法实现： Float f = Float.parseFloat(“12.1”);</li>
</ol>
<h5 id="基本数据类型转换成字符串"><a href="#基本数据类型转换成字符串" class="headerlink" title="基本数据类型转换成字符串"></a>基本数据类型转换成字符串</h5><ol>
<li>调用字符串重载的valueOf()方法： String fstr = String.valueOf(2.34f);</li>
<li>更直接的方式： String intStr = 5 + “”;</li>
</ol>
<p><img src="https://blog.steventan.top/images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AD%EF%BC%89/tS2914seKCUnAOl.png" alt=""></p>
<h4 id="包装类使用举例"><a href="#包装类使用举例" class="headerlink" title="包装类使用举例"></a>包装类使用举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">500</span>;</span><br><span class="line">Integer t = <span class="keyword">new</span> Integer(i);</span><br><span class="line"><span class="comment">//装箱：包装类使得一个基本数据类型的数据变成了类。</span></span><br><span class="line"><span class="comment">//有了类的特点，可以调用类中的方法。</span></span><br><span class="line">String s = t.toString(); <span class="comment">// s = "500",t是类，有toString方法</span></span><br><span class="line">String s1 = Integer.toString(<span class="number">314</span>); <span class="comment">// s1= "314" 将数字转换成字符串。</span></span><br><span class="line">String s2=“<span class="number">4.56</span>”;</span><br><span class="line"><span class="keyword">double</span> ds=Double.parseDouble(s2); <span class="comment">//将字符串转换成数字</span></span><br><span class="line"><span class="comment">//拆箱：将数字包装类中内容变为基本数据类型。</span></span><br><span class="line"><span class="keyword">int</span> j = t.intValue(); <span class="comment">// j = 500，intValue取出包装类中的数据</span></span><br><span class="line"><span class="comment">//包装类在实际开发中用的最多的在于字符串变为基本数据类型。</span></span><br><span class="line">String str1 = <span class="string">"30"</span> ;</span><br><span class="line">String str2 = <span class="string">"30.3"</span> ;</span><br><span class="line"><span class="keyword">int</span> x = Integer.parseInt(str1) ; <span class="comment">// 将字符串变为int型</span></span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(str2) ; <span class="comment">// 将字符串变为int型</span></span><br></pre></td></tr></table></figure>

<h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p>MVC是常用的设计模式之一，将整个程序分为三个层次：<strong>视图模型层，控制器层，与 数据模型层</strong>。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式 使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程 序的耦合性。</p>
<p>1.模型层 model 主要处理数据 </p>
<ul>
<li>数据对象封装 model.bean/domain </li>
<li>数据库操作类 model.dao </li>
<li>数据库 model.db</li>
</ul>
<p>2.控制层 controller 处理业务逻辑</p>
<ul>
<li>应用界面相关 controller.activity </li>
<li>存放fragment controller.fragment </li>
<li>显示列表的适配器 controller.adapter </li>
<li>服务相关的 controller.service </li>
<li>抽取的基类 controller.base</li>
</ul>
<p>3.视图层 view 显示数据</p>
<ul>
<li>相关工具类 view.utils </li>
<li>自定义view view.ui</li>
</ul>
<h2 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h2><ol>
<li>在源文件中使用import显式的导入指定包下的类或接口 </li>
<li>声明在包的声明和类的声明之间</li>
<li>如果需要导入多个类或接口，那么就并列显式多个import语句即可 </li>
<li>举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口</li>
<li>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句</li>
<li>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的 是哪个类</li>
<li>如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入</li>
<li>import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ol>
<h3 id="JDK中主要的包介绍"><a href="#JDK中主要的包介绍" class="headerlink" title="JDK中主要的包介绍"></a>JDK中主要的包介绍</h3><ol>
<li><p>java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System和 Thread，提供常用功能 </p>
</li>
<li><p>java.net—-包含执行与网络相关的操作的类和接口。 </p>
</li>
<li><p>java.io —-包含能提供多种输入/输出功能的类。</p>
</li>
<li><p>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日 期日历相关的函数。</p>
</li>
<li><p>java.text—-包含了一些java格式化相关的类 </p>
</li>
<li><p>java.sql—-包含了java进行JDBC数据库编程的相关类/接口 </p>
</li>
<li><p>java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这 些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中的权限管理</title>
    <url>/2020/05/15/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="文件基本权限"><a href="#文件基本权限" class="headerlink" title="文件基本权限"></a>文件基本权限</h1><p>首先看一下Linux中的文件权限，可以用ll命令或者带-l的ls命令查看</p>
<img src="https://blog.steventan.top/images/Linux中的权限管理/image-20200515135526284.png" alt="image-20200515135526284" style="zoom:80%;" />

<p>第一个字符代表文件的类型，然后是权限、链接数、所属用户、所属用户组、文件大小、最后修改时间、文件名</p>
<p>Linux中的文件权限一共有7种：</p>
<a id="more"></a>

<p>前面三种为常见的文件类型，后面四种是特殊文件类型</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件（如上图第三列）</td>
</tr>
<tr>
<td>d</td>
<td>文件目录（也就是文件夹）</td>
</tr>
<tr>
<td>l</td>
<td>软连接（和Windows中的快捷方式相似）</td>
</tr>
<tr>
<td>b</td>
<td>设备块文件（例如硬盘和光驱）</td>
</tr>
<tr>
<td>p</td>
<td>管道文件</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>s</td>
<td>套接口文件/数据接口文件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>权限</th>
<th>对应数字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>4</td>
<td>可读</td>
</tr>
<tr>
<td>w</td>
<td>2</td>
<td>可写</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
<td>可执行</td>
</tr>
</tbody></table>
<p>在看上面图中的第一个文件权限</p>
<p><strong>rwx——</strong></p>
<p>每三个字符为一组，-代表没有相关的权限</p>
<p>第一组是表示文件所有者（u表示）的权限，这里是root，root对该文件拥有所有的权限</p>
<p>第二组是表示所属组（g表示）的权限，这里也是root，这里所属组对该文件没有任何权限</p>
<p>第三组是表示其他人（o表示）的权限，这里也是没有任何权限的</p>
<p>新创建的文件默认权限：</p>
<img src="https://blog.steventan.top/images/Linux中的权限管理/image-20200515141738439.png" alt="image-20200515141738439" style="zoom:80%;" />

<h1 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h1><p>Linux中修改权限用的是chmod命令</p>
<p>具体用法见下图：</p>
<h2 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h2><p>给所属组加上写的权限</p>
<img src="https://blog.steventan.top/images/Linux中的权限管理/image-20200515141537125.png" alt="image-20200515141537125" style="zoom:80%;" />

<p>也可以同时给所属用户和用户组还有其他用户加权限</p>
<img src="https://blog.steventan.top/images/Linux中的权限管理/image-20200515142243765.png" alt="image-20200515142243765" style="zoom:80%;" />

<p>如果是要给全部的三个组同时加权限可以直接用a代表ugo，是就是all</p>
<p><img src="https://blog.steventan.top/images/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20200515142524794.png" alt="image-20200515142524794"></p>
<p>减权限，这里同理也可以用a代替ugo</p>
<img src="https://blog.steventan.top/images/Linux中的权限管理/image-20200515142333848.png" alt="image-20200515142333848" style="zoom:80%;" />

<h2 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h2><p>直接用代号赋予相应的权限，当要更改多个组的权限时，中间用逗号隔开</p>
<img src="https://blog.steventan.top/images/Linux中的权限管理/image-20200515142801089.png" alt="image-20200515142801089" style="zoom:80%;" />

<p><img src="https://blog.steventan.top/images/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20200515143020204.png" alt="image-20200515143020204"></p>
<p><img src="https://blog.steventan.top/images/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20200515143020204.png" alt="image-20200515143020204"></p>
<h2 id="方式三："><a href="#方式三：" class="headerlink" title="方式三："></a>方式三：</h2><p>用的比较多的其实是这一种</p>
<img src="https://blog.steventan.top/images/Linux中的权限管理/image-20200515143154536.png" alt="image-20200515143154536" style="zoom:80%;" />

<p>这里的每个数字就是刚刚对应权限代表的二进制转换过来的，这里544转换为方式二就是：u=rx,g=r,o=r，x的权重为1，w的权重为2，r的权重为4，把每个组的所有权限的权重加起来就是方式三的数字了。</p>
<p>这里再顺便介绍一个和权限相关的命令：</p>
<p>chown: 用来改变文件或目录的所有者</p>
<p>格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown user:user fileName</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用类</title>
    <url>/2020/06/06/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h1><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="String类的特性"><a href="#String类的特性" class="headerlink" title="String类的特性"></a>String类的特性</h3><ul>
<li>String类是字符串类，java中所有的字符串字面值，都作为此类的示例实现。</li>
<li>String类是一个final类，不可用继承，定义的变量是常量，定义之后也不能改变。</li>
<li>String对象的字符内容是存储在一个字符数组value[]中的。</li>
</ul>
<img src="https://blog.steventan.top/images/Java常用类/image-20200606144906113.png" alt="image-20200606144906113" style="zoom:80%;" />

<p>String str1 = “abc”;与String str2 = new String(“abc”);的区别？</p>
<ul>
<li>前者是一个字符串常量，存储在字符串常量池中，目的是共享。</li>
<li>后者是字符串非常量对象，存储在堆中。</li>
</ul>
<a id="more"></a>

<img src="https://blog.steventan.top/images/Java常用类/image-20200606145317796.png" alt="image-20200606145317796" style="zoom:80%;" />

<p>字符串对象的存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"javaEE"</span>;</span><br><span class="line">String s2 = <span class="string">"javaEE"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"javaEE"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"javaEE"</span>);</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<img src="https://blog.steventan.top/images/Java常用类/image-20200606145604487.png" alt="image-20200606145604487" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>,<span class="number">12</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>,<span class="number">12</span>);</span><br><span class="line">System.out.println(p1.name == p2.name);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<img src="https://blog.steventan.top/images/Java常用类/image-20200606145948843.png" alt="image-20200606145948843" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"hello"</span> + <span class="string">"world"</span>;</span><br><span class="line">String s4 = s1 + <span class="string">"world"</span>;</span><br><span class="line">String s5 = s1 + s2;</span><br><span class="line">String s6 = (s1 + s2).intern();</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s4 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<img src="https://blog.steventan.top/images/Java常用类/image-20200606150430936.png" alt="image-20200606150430936" style="zoom:80%;" />

<p>通过上面这些例子，可以总结出来：</p>
<ol>
<li>常量和常量的拼接结果任然在常量池，并且常量池中不会有相同内容的常量。</li>
<li>只要两个拼接的字符串有一个是变量，拼接的结果就在堆中。</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li>
</ol>
<h3 id="String的使用陷阱"><a href="#String的使用陷阱" class="headerlink" title="String的使用陷阱"></a>String的使用陷阱</h3><ul>
<li><p>String s1 = “a”; 说明：在字符串常量池中创建了一个字面量为”a”的字符串。 </p>
</li>
<li><p>s1 = s1 + “b”; 说明：实际上原来的“a”字符串对象<strong>已经丢弃了</strong>，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，<strong>会极大影响程序的性能</strong>。 </p>
</li>
<li><p>String s2 = “ab”; </p>
<p>说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。 </p>
</li>
<li><p>String s3 = “a” + “b”; </p>
<p>说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p>
</li>
<li><p>String s4 = s1.intern();</p>
<p>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p>
</li>
</ul>
<h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><ul>
<li><p>int length();  返回字符串的长度</p>
</li>
<li><p>char charAt(int index);  返回索引出的字符串</p>
</li>
<li><p>boolean isEmpty();  判断字符串是否为空</p>
</li>
<li><p>String toLowCase();  将字符串全部转换为小写</p>
</li>
<li><p>String toUpperCase();  将字符串全部转换为大写</p>
</li>
<li><p>String trim();  将字符串首位的空格去掉，返回字符串的副本</p>
</li>
<li><p>boolean equals(String str);  比较两个字符串内容是否相同</p>
</li>
<li><p>boolean equalsIgnoreCase(String str);  比较两个字符串内容是否相同，忽略大小写</p>
</li>
<li><p>String concat(String str);  将指定字符串拼接到该字符串的结尾</p>
</li>
<li><p>int conpareTo(String str);比较两个字符串的大小</p>
</li>
<li><p>String substring(int beginIndex);   返回一个从beginIndex开始到最后的一个字符的新字符串</p>
</li>
<li><p>String substring(int beginIndex, int endIndex);  返回一个从beginIndex开始到endIndex（不包含）结束的新字符串</p>
</li>
<li><p>boolean endsWith(String suffix);  判断此字符串是否以指定的后缀结束 </p>
</li>
<li><p>boolean startsWith(String prefix);  判断此字符串是否以指定的前缀开始 </p>
</li>
<li><p>boolean startsWith(String prefix, int toffset); 判断此字符串从指定索引开始的子字符串是否以指定前缀开始</p>
</li>
<li><p>boolean contains(CharSequence s);  判断当前字符串是否包含指定的 char 值序列</p>
</li>
<li><p>int indexOf(String str);  返回指定子字符串在此字符串中第一次出现处的索引 </p>
</li>
<li><p>int indexOf(String str, int fromIndex);  从指定的索引开始，获取指定子字符串在此字符串中第一次出现处的索引值</p>
</li>
<li><p>int lastIndexOf(String str);  返回指定子字符串在此字符串中最右边出现处的索引值</p>
</li>
<li><p>int lastIndexOf(String str, int fromIndex);  返回指定子字符串在此字符串中最后 一次出现处的索引值，从指定的索引开始反向搜索 <strong>注：indexOf()和lastIndexOf()方法如果未找到都是返回-1</strong></p>
</li>
<li><p>String replace(char oldChar, char newChar);  返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 </p>
</li>
<li><p>String replace(CharSequence target, CharSequence replacement);  使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</p>
</li>
<li><p>String replaceAll(String regex, String replacement) ;  使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。</p>
</li>
<li><p>String replaceFirst(String regex, String replacement) ; 使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串。</p>
</li>
<li><p>boolean matches(String regex); 判断此字符串是否匹配给定的正则表达式。</p>
</li>
<li><p>String[] split(String regex);  根据给定正则表达式的匹配拆分此字符串。</p>
</li>
<li><p>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p>
</li>
</ul>
<h3 id="String与字符数组的转换"><a href="#String与字符数组的转换" class="headerlink" title="String与字符数组的转换"></a>String与字符数组的转换</h3><ul>
<li><p>字符数组   —&gt;  字符串</p>
<p>String 类的构造器：String(char[]) 和 String(char[]，int offset，int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。</p>
</li>
<li><p>字符串  —&gt;  字符数组</p>
<p>char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法。</p>
<p>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法。</p>
</li>
</ul>
<h3 id="String与字节数组转换"><a href="#String与字节数组转换" class="headerlink" title="String与字节数组转换"></a>String与字节数组转换</h3><ul>
<li><p>字节数组  —&gt;  字符串</p>
<p>String(byte[])：通过使用平台的默认字符集解码指定的 byte 数组，构 造一个新的String。</p>
<p>String(byte[]，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</p>
</li>
<li><p>字符串  —&gt;  字节数组</p>
<p>public byte[] getBytes() ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。</p>
<p>public byte[] getBytes(String charsetName) ：使用指定的字符集将此String 编码到 byte 序列，并将结果存储到新的 byte 数组。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"中"</span>;</span><br><span class="line">System.out.println(str.getBytes(<span class="string">"ISO8859-1"</span>).length);<span class="comment">// -128~127</span></span><br><span class="line">System.out.println(str.getBytes(<span class="string">"GBK"</span>).length);</span><br><span class="line">System.out.println(str.getBytes(<span class="string">"UTF-8"</span>).length);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">"ISO8859-1"</span>),</span><br><span class="line">                              <span class="string">"ISO8859-1"</span>));<span class="comment">// 乱码，表示不了中文</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">"GBK"</span>), <span class="string">"GBK"</span>));</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(str.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><h3 id="StringBuffer类的特性"><a href="#StringBuffer类的特性" class="headerlink" title="StringBuffer类的特性"></a>StringBuffer类的特性</h3><ul>
<li>java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，库乐队字符串进行修改，并不会产生新的对象</li>
<li>StringBuffer类使用必须构造器生成对象，有三个构造器：<ul>
<li>StringBuffer()  初始容量为16的字符串缓冲区</li>
<li>StringBuffer(int size)  自定容量的字符串缓冲区</li>
<li>StringBuffer(String str)   将内容初始化为指定字符串内容</li>
</ul>
</li>
<li>很多方法与String相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"我喜欢学习"</span>);</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">"我喜欢学习"</span>);</span><br><span class="line">buffer.append(<span class="string">"数学"</span>);</span><br></pre></td></tr></table></figure>

<img src="https://blog.steventan.top/images/Java常用类/image-20200606180019262.png" alt="image-20200606180019262" style="zoom:80%;" />

<h3 id="StringBuffer类的常用方法"><a href="#StringBuffer类的常用方法" class="headerlink" title="StringBuffer类的常用方法"></a>StringBuffer类的常用方法</h3><ul>
<li><p>StringBuffer append(XXX)  提供了很多重载的append()方法,用于进行字符串拼接</p>
</li>
<li><p>StringBuffer delete(int start,int end)    删除指定位置的内容</p>
</li>
<li><p>StringBuffer replace(int start,int end,String str)   把[start,end)位置替换为str</p>
</li>
<li><p>StringBuffer insert(int offset, XXX) 在指定位置插入XXX</p>
</li>
<li><p>StringBuffer reverse()    把当前字符序列逆转</p>
<p>注意：在使用append()和insert()时，如果原来数组的长度不够，可以自动扩容</p>
</li>
</ul>
<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>StringBuilder类和StringBuffer类非常相似，类中提供的方法也差不多，这里不再赘述。</p>
<h2 id="String、StringBuffer和Stringbuilder三者的对比："><a href="#String、StringBuffer和Stringbuilder三者的对比：" class="headerlink" title="String、StringBuffer和Stringbuilder三者的对比："></a>String、StringBuffer和Stringbuilder三者的对比：</h2><p>String（JDK1.0）：不可变字符序列</p>
<p>StringBuffer（JDK1.0）：可变字符序列、线程安全、效率低</p>
<p>StringBuilder（JDK5.0）：可变字符序列、线程不安全、效率高</p>
<h1 id="时间日期相关的API"><a href="#时间日期相关的API" class="headerlink" title="时间日期相关的API"></a>时间日期相关的API</h1><h2 id="JDK8之前的"><a href="#JDK8之前的" class="headerlink" title="JDK8之前的"></a>JDK8之前的</h2><h3 id="java-lang-System类"><a href="#java-lang-System类" class="headerlink" title="java.lang.System类"></a>java.lang.System类</h3><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。此方法可以用于计算时间差。</p>
<h3 id="java-util-Date类"><a href="#java-util-Date类" class="headerlink" title="java.util.Date类"></a>java.util.Date类</h3><p>表示特定的瞬间，精确到毫秒</p>
<ul>
<li><p>构造器</p>
<p>Date()   获取本地当前时间</p>
<p>Date(long date)   传入一个毫秒数，将其转换为对应的时间</p>
</li>
<li><p>常用方法</p>
<ul>
<li><p>getTime()  返回自1970 年1月1日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</p>
</li>
<li><p>toString()  把此 Date 对象转换为以下形式的 String：dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon,Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。</p>
</li>
<li><p>其他很多方法都过时了</p>
</li>
</ul>
</li>
</ul>
<h3 id="java-text-SimpleDateFormate类"><a href="#java-text-SimpleDateFormate类" class="headerlink" title="java.text.SimpleDateFormate类"></a>java.text.SimpleDateFormate类</h3><ul>
<li><p>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p>
</li>
<li><p>SimpleDateFormate类可以对时间日期进行格式化：日期  –&gt;  文本、解析：文本  –&gt;  日期</p>
<ul>
<li><p>格式化：</p>
<p>SimpleDateFormat()   默认的格式和语言环境创建对象</p>
<p>SimpleDateFormat(String pattern)  该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用String format(Date date) 方法格式化时间对象date</p>
</li>
<li><p>解析：</p>
<p>Date parse(String source)   将给定的字符串解析为一个日期</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// 产生一个Date实例</span></span><br><span class="line"><span class="comment">// 产生一个formater格式化的实例</span></span><br><span class="line">SimpleDateFormat formater = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">System.out.println(formater.format(date));<span class="comment">// 打印输出默认的格式</span></span><br><span class="line">SimpleDateFormat formater2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 EEE HH:mm:ss"</span>);</span><br><span class="line">System.out.println(formater2.format(date));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 实例化一个指定的格式对象</span></span><br><span class="line">  Date date2 = formater2.parse(<span class="string">"2008年08月08日 星期一 08:08:08"</span>);</span><br><span class="line">  <span class="comment">// 将指定的日期解析后格式化按指定的格式输出</span></span><br><span class="line">  System.out.println(date2.toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="java-util-Calendar类"><a href="#java-util-Calendar类" class="headerlink" title="java.util.Calendar类"></a>java.util.Calendar类</h3><h4 id="Calender描述"><a href="#Calender描述" class="headerlink" title="Calender描述"></a>Calender描述</h4><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能</p>
<h4 id="获取Calender实例的方法"><a href="#获取Calender实例的方法" class="headerlink" title="获取Calender实例的方法"></a>获取Calender实例的方法</h4><p>1.使用Calender.getInstance()方法</p>
<p>2.调用他的子类GregorianCalender的构造器</p>
<p>一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND。</p>
<ul>
<li>public void set(int field,int value)</li>
<li>public void add(int field,int amount)</li>
<li>public final Date getTIme()</li>
<li>public final void setTime(Date date)</li>
</ul>
<p>注意：</p>
<ol>
<li>获取月份时：一月是0二月是1，以此类推，十二月是11</li>
<li>获取星期时：周日是1，周二是2……周六是7</li>
</ol>
<h2 id="JDK8中新的"><a href="#JDK8中新的" class="headerlink" title="JDK8中新的"></a>JDK8中新的</h2><blockquote>
<p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是： </p>
<p>可变性：像日期和时间这样的类应该是不可变的。 </p>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。 </p>
<p>格式化：格式化只对Date有用，Calendar则不行。 </p>
<p>此外，它们也不是线程安全的；不能处理闰秒等。</p>
</blockquote>
<h3 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h3><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime） 和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简 化了日期时间和本地化的管理。</p>
<ul>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，不是日期。</li>
<li>LocalDateTime是用来表示日期和时间的，是最常用的类之一。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now()/ now(ZoneId zone)</td>
<td>静态方法，根据当前时间创建对象/指定时区的对象</td>
</tr>
<tr>
<td>of()</td>
<td>静态方法，根据指定的日期/时间创建对象</td>
</tr>
<tr>
<td>getDayOfMonth/getDayOfYear()</td>
<td>获得月份天数(1-31)/获得年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期(返回一个DayOfWeek枚举值)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获得月份，返回一个Month枚举值</td>
</tr>
<tr>
<td>getMonthValue()/getYear()</td>
<td>获得月份(1-12)/获得年份</td>
</tr>
<tr>
<td>getHour()/getMinute()/getSecond()</td>
<td>获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Duration:用于计算两个“时间”间隔，以秒和纳秒为基准</span></span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalTime localTime1 = LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line">Duration duration = Duration.between(localTime1, localTime);</span><br><span class="line">System.out.println(duration);</span><br><span class="line">System.out.println(duration.getSeconds());</span><br><span class="line">System.out.println(duration.getNano());</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">Duration duration1 = Duration.between(localDateTime1, localDateTime);</span><br><span class="line">System.out.println(duration1.toDays());</span><br></pre></td></tr></table></figure>

<h3 id="Instant（瞬时）"><a href="#Instant（瞬时）" class="headerlink" title="Instant（瞬时）"></a>Instant（瞬时）</h3><p>instant：时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳。</p>
<p>在处理时间和日期的时候，我们通常会想到年，月，日，时，分，秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</p>
<p> java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</p>
<h3 id="格式化与解析日期或时间"><a href="#格式化与解析日期或时间" class="headerlink" title="格式化与解析日期或时间"></a>格式化与解析日期或时间</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p>
<p>预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</p>
<p>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</p>
<p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ofPattern(String pattern)</td>
<td>静态方法 ， 返回一个指定字符串格式的DateTimeFormatter</td>
</tr>
<tr>
<td>format(TemporalAccessor t)</td>
<td>格式化一个日期、时间，返回字符串。</td>
</tr>
<tr>
<td>parse(CharSequence text)</td>
<td>将制定的字符串序列解析为一个日期、时间</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他相关API"><a href="#其他相关API" class="headerlink" title="其他相关API"></a>其他相关API</h2><ul>
<li>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris </li>
<li>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12- 03T10:15:30+01:00 Europe/Paris。 </li>
<li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如： Asia/Shanghai等 </li>
<li>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。 </li>
<li>持续时间：Duration，用于计算两个“时间”间隔 </li>
<li>日期间隔：Period，用于计算两个“日期”间隔 </li>
<li>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整 到“下一个工作日”等操作。       </li>
<li>TemporalAdjusters : 该类通过静态方法 (firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</li>
</ul>
<h1 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h1><blockquote>
<p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间 的比较问题。 </p>
<p>Java实现对象排序的方式有两种： </p>
<ul>
<li><p>自然排序：java.lang.Comparable </p>
</li>
<li><p>定制排序：java.util.Comparator</p>
</li>
</ul>
</blockquote>
<h2 id="自然排序：java-lang-Comparable"><a href="#自然排序：java-lang-Comparable" class="headerlink" title="自然排序：java.lang.Comparable"></a>自然排序：java.lang.Comparable</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。</p>
<p>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。</p>
<p>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有 序集合中的元素，无需指定比较器。</p>
<p>各个数据类型的比较方式：</p>
<ul>
<li>String：按照字符串中字符的Unicode值进行比较</li>
<li>Character：按照字符的中字符的Unicode值进行比较</li>
<li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</li>
<li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li>
<li>Date、Time等：后面的日期时间比前面的日期时间大</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  <span class="comment">//按照价格，比较商品的大小</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">      Goods other = (Goods) o;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; other.price) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.price &lt; other.price) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的数据类型不一致"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构造器、getter、setter、toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定制排序：java-util-Comparator"><a href="#定制排序：java-util-Comparator" class="headerlink" title="定制排序：java.util.Comparator"></a>定制排序：java.util.Comparator</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator 的对象来排序，强行对多个对象进行整体排序的比较。</p>
<p>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返 回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示 o1小于o2。</p>
<p>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort）， 从而允许在排序顺序上实现精确控制。</p>
<p>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的 顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Goods[] all = <span class="keyword">new</span> Goods[<span class="number">4</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">"War and Peace"</span>, <span class="number">100</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">"Childhood"</span>, <span class="number">80</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">"Scarlet and Black"</span>, <span class="number">140</span>);</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">"Notre Dame de Paris"</span>, <span class="number">120</span>);</span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    Goods g1 = (Goods) o1;</span><br><span class="line">    Goods g2 = (Goods) o2;</span><br><span class="line">    <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(all));</span><br></pre></td></tr></table></figure>



<h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p>
<p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便 的进行调用。</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>System类内部包含in、out和err三个成员变量，分表代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p>native long currentTimeMillis()</p>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 </p>
</li>
<li><p>void exit(int status)</p>
<p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</li>
<li><p>void gc()</p>
<p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
</li>
<li><p>String getProperty(String key)</p>
<p>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>java.version</td>
<td>java运行时环境（JRE）版本</td>
</tr>
<tr>
<td>java.home</td>
<td>java安装目录</td>
</tr>
<tr>
<td>os.name</td>
<td>操作系统名称</td>
</tr>
<tr>
<td>os.version</td>
<td>操作系统版本</td>
</tr>
<tr>
<td>user.name</td>
<td>用户的账户名</td>
</tr>
<tr>
<td>user.home</td>
<td>用户的主目录</td>
</tr>
<tr>
<td>user.dir</td>
<td>用户的当前的工作目录</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回 值类型一般为double型。 </p>
<p>abs 绝对值 </p>
<p>acos,asin,atan,cos,sin,tan 三角函数 </p>
<p>sqrt 平方根 </p>
<p>pow(double a,doble b) a的b次幂 </p>
<p>log 自然对数 exp e为底指数 </p>
<p>max(double a,double b)   取两者大的一个</p>
<p>min(double a,double b)    取两者小的一个</p>
<p>random() 返回0.0到1.0的随机数 </p>
<p>long round(double a)   double型数据a转换为long型（四舍五入） </p>
<p>toDegrees(double angrad) 弧度—&gt;角度 </p>
<p>toRadians(double angdeg) 角度—&gt;弧度</p>
<h1 id="BigInteger和BigDecimal"><a href="#BigInteger和BigDecimal" class="headerlink" title="BigInteger和BigDecimal"></a>BigInteger和BigDecimal</h1><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>Integer类作为int的包装类，能存储的最大整型值为2 31-1，Long类也是有限的，最大为2 63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类 都无能为力，更不用说进行运算了。</p>
<p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、 位操作以及一些其他操作。</p>
<p>常用方法：</p>
<ul>
<li><p>public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 </p>
</li>
<li><p>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的BigInteger </p>
</li>
<li><p>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger </p>
</li>
<li><p>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</p>
</li>
<li><p>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数 相除只保留整数部分。</p>
</li>
<li><p>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 </p>
</li>
<li><p>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟(this % val) 的两个 BigInteger 的数组。 </p>
</li>
<li><p>BigInteger pow(int exponent) ：返回其值为 (thisexponent) 的 BigInteger。</p>
</li>
</ul>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。</p>
<p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
<p>常用方法：</p>
<ul>
<li>public BigDecimal add(BigDecimal augend) </li>
<li>public BigDecimal subtract(BigDecimal subtrahend) </li>
<li>public BigDecimal multiply(BigDecimal multiplicand) </li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/2020/02/27/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">###### 六级标题</span></span><br></pre></td></tr></table></figure>



<p><strong>注意#和标题之间要有空格才会有效果</strong>   这简直是初学者的一大坑  </p>
<a id="more"></a>

<h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*斜体1*	 _斜体2_</span><br><span class="line">**加粗1**  __加粗2__</span><br><span class="line">==强调== </span><br><span class="line">~~删除线~~</span><br><span class="line">H~2~O	（hexo要用&lt;sub&gt;&lt;/sub&gt;标签，如H&lt;sub&gt;2&lt;/sub&gt;O）</span><br><span class="line">2^10^   （hexo要用&lt;sup&gt;&lt;/sup&gt;标签，如2&lt;sup&gt;10&lt;/sup&gt;）</span><br><span class="line">&gt; 引用</span><br></pre></td></tr></table></figure>

<p><strong>效果显示</strong></p>
<p><em>斜体1</em>     <em>斜体2</em><br><strong>加粗1</strong>     <strong>加粗2</strong><br>==强调==<br><del>删除线</del></p>
<p>H<sub>2</sub>O<br>2<sup>10</sup></p>
<blockquote>
<p>引用</p>
</blockquote>
<p><strong>后面两个要在偏好里面设置，Markdown扩展语法那几个选项打上勾</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 项目1</span><br><span class="line">  </span><br><span class="line">  - 项目2</span><br><span class="line">  </span><br><span class="line">    - 项目3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>项目1</p>
<ul>
<li><p>项目2</p>
<ul>
<li>项目3</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 项目</span><br><span class="line">2. 项目</span><br><span class="line">3. 项目</span><br></pre></td></tr></table></figure>

<ol>
<li>项目</li>
<li>项目</li>
<li>项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [ ] 计划任务</span><br><span class="line">- [x] 完成任务</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 计划任务</li>
<li><input checked="" disabled="" type="checkbox"> 完成任务 </li>
</ul>
<h4 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">​```c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![](图片链接)</span><br></pre></td></tr></table></figure>



<p>今天先写到这，睡觉去了🌛 🌜</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之集合框架</title>
    <url>/2020/06/16/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Java-集合框架概述"><a href="#Java-集合框架概述" class="headerlink" title="Java 集合框架概述"></a>Java 集合框架概述</h1><blockquote>
<p>一方面， 面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。</p>
</blockquote>
<ul>
<li><p>数组在内存中存储方面的特点：</p>
<p>​    数组初始化之后，长度就确定了，不能更改了</p>
<p>​    数组声明的类型，就决定了元素初始化时候的类型</p>
</li>
<li><p>数组在存储方面的弊端：</p>
<p>​    数组初始化之后，长度就不能改变了，不便于扩展</p>
<p>​    数组中提供的属性和方法较少，不便于进行增删改查插入等操作，且效率不高。数组无法直接获取存储元素的个数</p>
<p>​    数组存储的数据是有序的，可以重复的，存储的特点单一</p>
</li>
</ul>
<p>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</p>
<p>Java 集合可分为 Collection 和 Map 两种体系 ：</p>
<p>Collection接口：单列数据，定义了存取一组对象的方法的集合 </p>
<p>​    List：元素有序、可重复的集合 </p>
<p>​    Set：元素无序、不可重复的集合 </p>
<p>Map接口：双列数据，保存具有映射关系“key-value对”的集合</p>
<a id="more"></a>

<p>Collection接口继承树：</p>
<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200617143455167.png" alt="image-20200617143455167" style="zoom:67%;" />

<p>Map接口继承树：</p>
<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200617143554774.png" alt="image-20200617143554774" style="zoom:67%;" />

<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li>
<li>在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都 当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容器中对象的数据类型。</li>
</ol>
<h2 id="Collection接口中的方法"><a href="#Collection接口中的方法" class="headerlink" title="Collection接口中的方法"></a>Collection接口中的方法</h2><ol>
<li><p>添加</p>
<p>add(Object obj)</p>
<p>addAll(Collection coll)</p>
</li>
<li><p>获取有效元素的个数</p>
<p>int size()</p>
</li>
<li><p>清空集合</p>
<p>void clear()</p>
</li>
<li><p>判断是否为空</p>
<p>boolean isEmpty()</p>
</li>
<li><p>判断是否包含某个元素</p>
<p>boolean contains(Object obj)   是通过元素的equals方法来判断是否是同一个对象</p>
<p>boolean contains(Collection coll)   也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</p>
</li>
<li><p>删除</p>
<p>boolean remove(Object obj)   通过元素的equals方法判断是否存在该元素，再将其删除，但是只会删除找到的第一个匹配的元素</p>
<p>boolean removeAll(Collection coll)   取两个集合的差集</p>
</li>
<li><p>取两个集合的交集</p>
<p>boolean retainAll(Collection c)   把交集的结果存在当前集合中，c不会改变</p>
</li>
<li><p>集合是否相等</p>
<p>boolean equals(Object obj)</p>
</li>
<li><p>转换成对象数组</p>
<p>Object[] toArray()</p>
</li>
<li><p>获取集合对象的哈希值</p>
<p>hashCode()</p>
</li>
<li><p>遍历</p>
<p>iterator()  返回迭代器对象，用于遍历集合</p>
</li>
</ol>
<h3 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h3><ul>
<li><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 </p>
</li>
<li><p>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。 </p>
</li>
<li><p>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了 Iterator接口的对象。 </p>
</li>
<li><p>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。 </p>
</li>
<li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p>
</li>
</ul>
<h4 id="Iterator接口中的方法"><a href="#Iterator接口中的方法" class="headerlink" title="Iterator接口中的方法"></a>Iterator接口中的方法</h4><p>Collection集合常用下图所示方法遍历:</p>
<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200617152119103.png" alt="image-20200617152119103" style="zoom:67%;" />

<ol>
<li>boolean hasNext()  判断迭代器是否还有下一个元素</li>
<li>next()  将迭代器的指针移向下一个元素</li>
<li>remove()  移除一个元素</li>
</ol>
<p>注意：</p>
<ol>
<li>在调用next()方法之前，若果不用hasNext()进行检测，则可能会出现NoSuchElementException异常</li>
<li>Iterator删除集合的元素，是在遍历过程中通过迭代器对象的remove方法删除，而不是集合对象的remove()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iter = coll.iterator();<span class="comment">//回到起点</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">  Object obj = iter.next();</span><br><span class="line">  <span class="keyword">if</span>(obj.equals(<span class="string">"Tom"</span>))&#123;</span><br><span class="line">    iter.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上面这种用迭代器遍历集合的方法，还可以用foreach（又叫增强for循环）来遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object obj: coll)&#123;</span><br><span class="line">  System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接用Collection中的forEach()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">coll.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="Collection子接口：List接口"><a href="#Collection子接口：List接口" class="headerlink" title="Collection子接口：List接口"></a>Collection子接口：List接口</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>List集合类中元素有序、可以重复，集合中每个元素都有其对应的顺序索引，每个元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。List接口的实现类常用的有：ArrayList、LinkedList和Vector。</p>
<h3 id="List接口中的方法"><a href="#List接口中的方法" class="headerlink" title="List接口中的方法"></a>List接口中的方法</h3><p>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。</p>
<ul>
<li>void add(int index, Object elem)  在index位置插入elem元素</li>
<li>boolean addAll(int index, Collection eles)  从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index)  获取指定index位置的元素</li>
<li>int indexOf(Object obj)  返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj)  返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index)  移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object elem):设置指定index位置的元素为elem</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
<h3 id="List的主要实现类：ArrayList"><a href="#List的主要实现类：ArrayList" class="headerlink" title="List的主要实现类：ArrayList"></a>List的主要实现类：ArrayList</h3><p>ArrayList的底层还是通过数组来实现的</p>
<p>在JDK1.7中ArrayList像饿汉式，在创建List对象的时候就直接创建了一个初始容量为10的数组；</p>
<p>在JDK1.8中ArrayList像懒汉式，创建对象的时候创建一个长度为0的数组，当添加第一个元素的时候再创建一个容量为10的数组。</p>
<p>注意：Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合</p>
<h3 id="List实现类之二：LinkedList"><a href="#List实现类之二：LinkedList" class="headerlink" title="List实现类之二：LinkedList"></a>List实现类之二：LinkedList</h3><p>因为LinkedList底层是用链表实现的，所以插入和删除的效率比ArrayList要搞，对于频繁的插入和删除，建议使用LinkedList。</p>
<p>LinkedList中的方法：</p>
<ul>
<li><p>void addFirst(Object obj) </p>
</li>
<li><p>void addLast(Object obj) </p>
</li>
<li><p>Object getFirst() </p>
</li>
<li><p>Object getLast() </p>
</li>
<li><p>Object removeFirst() </p>
</li>
<li><p>Object removeLast()</p>
</li>
</ul>
<p>具体的底层实现：</p>
<p>LinkedList底层是用双向链表实现的，内部定义了Node类型的first和last，用于记录首末元素。同时定义内部类Node，作为LinkedList保存数据的基本结构，Node除了保存数据还定义了两个变量：</p>
<ul>
<li>prev变量记录前一个元素的位置</li>
<li>next变量记录下一个元素的位置</li>
</ul>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  E item;</span><br><span class="line">  Node&lt;E&gt; next;</span><br><span class="line">  Node&lt;E&gt; prev;</span><br><span class="line">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200617204129667.png" alt="image-20200617204129667" style="zoom:67%;" />

<h3 id="List-实现类之三：Vector"><a href="#List-实现类之三：Vector" class="headerlink" title="List 实现类之三：Vector"></a>List 实现类之三：Vector</h3><p>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</p>
<p>新增方法:</p>
<p>void addElement(Object obj) </p>
<p>void insertElementAt(Object obj,int index) </p>
<p>void setElementAt(Object obj,int index) </p>
<p>void removeElement(Object obj) </p>
<p>void removeAllElements()</p>
<h3 id="ArrayList-LinkedList-Vector的异同"><a href="#ArrayList-LinkedList-Vector的异同" class="headerlink" title="ArrayList/LinkedList/Vector的异同"></a>ArrayList/LinkedList/Vector的异同</h3><ul>
<li><p>ArrayList和LinkedList的异同 </p>
<p>二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p>
</li>
<li><p>ArrayList和Vector的区别</p>
<p>Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用 ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</p>
</li>
</ul>
<h2 id="Collection子接口：Set接口"><a href="#Collection子接口：Set接口" class="headerlink" title="Collection子接口：Set接口"></a>Collection子接口：Set接口</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>Set接口是Collection的子接口，set接口没有提供额外的方法。</li>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set集合中，则添加操作失败。</li>
<li>Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法</li>
</ul>
<h3 id="Set主要实现类：HashSet"><a href="#Set主要实现类：HashSet" class="headerlink" title="Set主要实现类：HashSet"></a>Set主要实现类：HashSet</h3><p>HashSet 按 Hash 算法来存储集合中的元素，具有很好的存取、查找、删除性能。</p>
<h4 id="HashSet特点"><a href="#HashSet特点" class="headerlink" title="HashSet特点"></a>HashSet特点</h4><ol>
<li><p>无序性，不能保证元素的排列顺序</p>
</li>
<li><p>不可重复性，HashSet中不能有两个相同的元素</p>
</li>
<li><p>线程不安全</p>
</li>
<li><p>集合元素可以为null</p>
<p>HashSet判断两个元素相同的标准：</p>
</li>
</ol>
<p>两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。</p>
<p><strong>注意：</strong></p>
<p>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。</p>
<h4 id="向HashSet中添加元素的过程"><a href="#向HashSet中添加元素的过程" class="headerlink" title="向HashSet中添加元素的过程"></a>向HashSet中添加元素的过程</h4><p>​        首先会调用该对象的HashCode()方法，来得到该对象的HashCode值，然后根据HashCode的值，通过某种散列函数决定该对象在HashSet底层数组中的存储位置（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）。</p>
<p>​        如果该位置没有存储其他元素，那么就直接添加成功；如果已经有元素了，则比较两个元素的HashCode值。</p>
<p>​        如果两个元素的哈希值不相等，那么就可以通过链表的方式将添加的元素和原来有的元素链接起来；如果两个元素的哈希值相等，就要调用equals() 方法比较两个元素是否一样了。</p>
<p>​        如果equals() 方法返回true，则添加失败，如果返回false，则添加成功，该元素通过链表的方式和原来链接的元素链接在一起。</p>
<p>HashSet的底层实现实际上是HashMap，如下图所示：</p>
<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200618104823685.png" alt="image-20200618104823685" style="zoom:80%;" />

<h3 id="Set实现类之二：LinkedHashSet"><a href="#Set实现类之二：LinkedHashSet" class="headerlink" title="Set实现类之二：LinkedHashSet"></a>Set实现类之二：LinkedHashSet</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>LinkedHashSet 是 HashSet 的子类</p>
<p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，<strong>这使得元素看起来是以插入顺序保存的</strong>。</p>
<p>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p>
<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200618105842213.png" alt="image-20200618105842213" style="zoom:80%;" />

<h3 id="Set实现类之三：TreeSet"><a href="#Set实现类之三：TreeSet" class="headerlink" title="Set实现类之三：TreeSet"></a>Set实现类之三：TreeSet</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。TreeSet底层使用红黑树结构存储数据。</p>
<p>新增的方法如下： (了解) </p>
<ul>
<li>Comparator comparator() </li>
<li>Object first() </li>
<li>Object last() </li>
<li>Object lower(Object e) </li>
<li>Object higher(Object e) </li>
<li>SortedSet subSet(fromElement, toElement) </li>
<li>SortedSet headSet(toElement) </li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200618110742069.png" alt="image-20200618110742069" style="zoom:80%;" />

<h4 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h4><p>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。</p>
<p>注意：如果要把一个对象添加到TreeSet中，则该对象的类必须实现Comparable接口。实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。</p>
<p>向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</p>
<p>因为只有相同类的两个实例才能比较，所以向 TreeSet 中添加的应该是同一个类的对象。</p>
<p>对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通 过 compareTo(Object obj) 方法比较返回值。</p>
<h4 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h4><p>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。</p>
<p>利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</p>
<p>注意：</p>
<ol>
<li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li>
<li>在这里仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异 常。</li>
<li>使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</li>
</ol>
<p>面试题：</p>
<p>其中Person类中重写了hashCode()和equal()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">"AA"</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="number">1002</span>,<span class="string">"BB"</span>);</span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">p1.name = <span class="string">"CC"</span>;</span><br><span class="line">set.remove(p1);</span><br><span class="line">System.out.println(set);<span class="comment">//输出两个</span></span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">"CC"</span>));</span><br><span class="line">System.out.println(set);<span class="comment">//输出三个</span></span><br><span class="line">set.add(<span class="keyword">new</span> Person(<span class="number">1001</span>,<span class="string">"AA"</span>));</span><br><span class="line">System.out.println(set);<span class="comment">//输出四个</span></span><br></pre></td></tr></table></figure>

<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map接口继承树：</p>
<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200618153453173.png" alt="image-20200618153453173" style="zoom:67%;" />

<h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>Map与Collection并列存在。用于保存具有映射关系的数据:key-value&gt;</p>
</li>
<li><p>Map 中的 key 和 value 都可以是任何引用类型的数据</p>
</li>
<li><p>Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，必须重写hashCode()和equals()方法</p>
</li>
<li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value</p>
</li>
<li><p>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和 Properties。其中，HashMap是 Map 接口使用频率最高的实现类</p>
</li>
</ul>
<h2 id="Map接口的常用方法"><a href="#Map接口的常用方法" class="headerlink" title="Map接口的常用方法"></a>Map接口的常用方法</h2><h3 id="增删改相关方法"><a href="#增删改相关方法" class="headerlink" title="增删改相关方法"></a>增删改相关方法</h3><p>Object put(Object key,Object value)    将指定key-value添加到(或修改)当前map对象中 </p>
<p>void putAll(Map m)   将m中的所有key-value对存放到当前map中 </p>
<p>Object remove(Object key)   移除指定key的key-value对，并返回value </p>
<p>void clear()   清空当前map中的所有数据</p>
<h3 id="查询相关方法"><a href="#查询相关方法" class="headerlink" title="查询相关方法"></a>查询相关方法</h3><p>Object get(Object key)   获取指定key对应的value </p>
<p>boolean containsKey(Object key)  是否包含指定的key </p>
<p>boolean containsValue(Object value)：是否包含指定的value </p>
<p>int size()   返回map中key-value对的个数 </p>
<p>boolean isEmpty()   判断当前map是否为空 </p>
<p>boolean equals(Object obj)   判断当前map和参数对象obj是否相等</p>
<h3 id="元视图操作的相关方法"><a href="#元视图操作的相关方法" class="headerlink" title="元视图操作的相关方法"></a>元视图操作的相关方法</h3><p>Set keySet()   返回所有key构成的Set集合 </p>
<p>Collection values()   返回所有value构成的Collection集合 </p>
<p>Set entrySet()：返回所有key-value对构成的Set集合</p>
<h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">//map.put(..,..)省略</span></span><br><span class="line">System.out.println(<span class="string">"map的所有key:"</span>);</span><br><span class="line">Set keys = map.keySet();<span class="comment">// HashSet</span></span><br><span class="line"><span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">  System.out.println(key + <span class="string">"-&gt;"</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"map的所有的value："</span>);</span><br><span class="line">Collection values = map.values();</span><br><span class="line">Iterator iter = values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">  System.out.println(iter.next());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"map所有的映射关系："</span>);</span><br><span class="line"><span class="comment">// 映射关系的类型是Map.Entry类型，它是Map接口的内部接口</span></span><br><span class="line">Set mappings = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Object mapping : mappings) &#123;</span><br><span class="line">  Map.Entry entry = (Map.Entry) mapping;</span><br><span class="line">  System.out.println(<span class="string">"key是："</span> + entry.getKey() + <span class="string">"，value是："</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map的主要实现类：HashMap"><a href="#Map的主要实现类：HashMap" class="headerlink" title="Map的主要实现类：HashMap"></a>Map的主要实现类：HashMap</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><ul>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>
<li>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</li>
<li>所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals()</li>
<li>一个key-value构成一个entry</li>
<li>所有的entry构成的集合是Set:无序的、不可重复的</li>
<li>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等； 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。</li>
</ul>
<h3 id="HashMap的存储结构"><a href="#HashMap的存储结构" class="headerlink" title="HashMap的存储结构"></a>HashMap的存储结构</h3><p>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法) </p>
<p>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</p>
<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200619171812979.png" alt="image-20200619171812979" style="zoom:80%;" />

<img src="https://blog.steventan.top/images/Java基础之集合框架/image-20200619171905874.png" alt="image-20200619171905874" style="zoom:80%;" />

<h3 id="HashMap源码中的重要常量"><a href="#HashMap源码中的重要常量" class="headerlink" title="HashMap源码中的重要常量"></a>HashMap源码中的重要常量</h3><p>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 </p>
<p>MAXIMUM_CAPACITY： HashMap的最大支持容量，2^30^</p>
<p>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子，0.75</p>
<p>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树，8</p>
<p>UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表 </p>
<p>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量，64（当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4 倍） </p>
<p>table：存储元素的数组，总是2的n次幂 </p>
<p>entrySet：存储具体元素的集 </p>
<p>size：HashMap中存储的键值对的数量 </p>
<p>modCount：HashMap扩容和结构改变的次数。 </p>
<p>threshold：扩容的临界值 = 容量 * 加载因子 </p>
<p>loadFactor：加载因子  </p>
<h3 id="HashMap底层实现（JDK8）"><a href="#HashMap底层实现（JDK8）" class="headerlink" title="HashMap底层实现（JDK8）"></a>HashMap底层实现（JDK8）</h3><p>HashMap的内部存储结构其实是<strong>数组+链表+红黑树</strong>。当实例化一个HashMap时，系统会创建一个长度为Capacity的Node数组（JDK8中没添加元素之前为0，在第一次add操作之后才会创建一个实际长度为16），这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
<p>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带 一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象 可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</p>
<h4 id="添加元素的过程"><a href="#添加元素的过程" class="headerlink" title="添加元素的过程"></a>添加元素的过程</h4><p>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据 key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Node[]数组中要存储的位置i。</p>
<p>如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。</p>
<p>如果彼此hash值不同，则直接添加成功如果 hash值相同，继续调用二者的equals()方法，如果返回值为true，则使用entry1的value 去替换equals为true的entry的value。</p>
<p>如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。</p>
<p>JDK8中添加的核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; </span><br><span class="line">  Node&lt;K,V&gt; p; </span><br><span class="line">  <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="comment">//判断数组是否已经创建，若没有创建调用resize()方法创建一个长度为16的数组</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) </span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">//判断该位置上数组是否已经存了数据，如果没有，就直接调用newNode()方法将新元素放到该位置</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//如果该位置已经放了元素，就需要进行一系列的比较了</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">//如果和第一个位置元素哈希值相等，并且key也是一样的，那么久直接将这个key对应的value替换掉</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">//如果哈希值不相等，判断这个数组是不是属树形的结构，如果是就调用相关方法再比较</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="comment">//如果不是树形结构，接直接从这个链表的头部开始遍历</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//指向第一个元素的下一个节点为null，也就意味着将链表中的元素全部比较完了，并且都不一样</span></span><br><span class="line">        <span class="comment">//就将这个元素添加到这个链表后面</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">//如果链表的长度大于默认值(8)，就讲其转换为红黑树</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">//要转换为红黑树，方法里面还会判断一下，数组的长度是不是大于64</span></span><br><span class="line">            <span class="comment">//大于的话才会转换为红黑树，否则只是进行一个扩容</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果哈希值一样，并且key也是一样的，就跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是存在相同key的情况，只对其value进行更新</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h4><p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p>扩容核心源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">//得到原来数组的容量</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//如果原来的容量大于0</span></span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果大于最大的容量，将临界值改为最大的整数</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则就将其左移一位，也就是扩大一倍。</span></span><br><span class="line">    <span class="comment">//前提是扩容后的容量要小于最大容量，并且原来的容量要大于默认容量(16)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果原来的容量为0且扩容临界值大于0，就将其赋给容量</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="comment">//如果两者都为0</span></span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容的时机：</p>
<p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数 size) * loadFactor 时， 就会进行数 组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况 下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数 超过16 * 0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把 数组的大小扩展为 (16 &lt;&lt; 2) = 32，即扩大一倍，然后重新计算每个元素在数组中的位置， 而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数， 那么预设元素的个数能够有效的提高HashMap的性能。</p>
<p>树形化的条件：</p>
<p>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后， 下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</p>
<p><strong>小结：</strong></p>
<ol>
<li><p>HashMap map = new HashMap();  //默认情况下，先不创建长度为16的数组 </p>
</li>
<li><p>当首次调用map.put()时，再创建长度为16的数组 </p>
</li>
<li><p>数组为Node类型，在jdk7中称为Entry类型 </p>
</li>
<li><p>形成链表结构时，新添加的key-value对在链表的尾部（七上八下） </p>
</li>
<li><p>当数组指定索引位置的链表长度大于8时，且map中的数组的长度大于64时，此索引位置 上的所有key-value对使用红黑树进行存储。</p>
</li>
</ol>
<h4 id="负载因子的大小，对HashMap的影响"><a href="#负载因子的大小，对HashMap的影响" class="headerlink" title="负载因子的大小，对HashMap的影响"></a>负载因子的大小，对HashMap的影响</h4><ul>
<li>负载因子的大小决定了HashMap的数据密度。 </li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。 </li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内存空间。而且经常扩容也会影响性能，建 议初始化预设大一点的空间。 </li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数。</li>
</ul>
<h2 id="Map实现类之二：LinkedHashMap"><a href="#Map实现类之二：LinkedHashMap" class="headerlink" title="Map实现类之二：LinkedHashMap"></a>Map实现类之二：LinkedHashMap</h2><p>LinkedHashMap是HashMap的子类，LinkedHashMap在HashMap的存储基础上，使用了一对双向链表来记录添加元素的顺序。</p>
<p>HashMap中的内部类：Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap中的内部类：Entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; before, after;</span><br><span class="line">  Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map实现类之三：TreeMap"><a href="#Map实现类之三：TreeMap" class="headerlink" title="Map实现类之三：TreeMap"></a>Map实现类之三：TreeMap</h2><p>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序，TreeMap 可以保证所有的 Key-Value 对处于有序状态。TreeSet底层使用的是红黑树结构存储数据。</p>
<p>TreeMap 的 Key 的排序：</p>
<ul>
<li><p>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</p>
</li>
<li><p>定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</p>
</li>
</ul>
<p>TreeMap判断两个key相等的标准：</p>
<p>​    两个key通过compareTo()方法或 者compare()方法返回0。</p>
<h2 id="Map实现类之四：Hashtable"><a href="#Map实现类之四：Hashtable" class="headerlink" title="Map实现类之四：Hashtable"></a>Map实现类之四：Hashtable</h2><p>Hashtable是个古老的 Map 实现类，JDK1.0就提供了，和HashMap的区别在于Hashtable是线程安全的，并且Hashtable 不允许使用 null 作为 key 和 value。Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</p>
<h2 id="Map实现类之五：Properties"><a href="#Map实现类之五：Properties" class="headerlink" title="Map实现类之五：Properties"></a>Map实现类之五：Properties</h2><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件。由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型。</p>
<p>存取数据时，建议使用setProperty(String key,String value)方法和 getProperty(String key)方法。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(<span class="keyword">new</span> FileInputStream(<span class="string">"jdbc.properties"</span>));</span><br><span class="line">String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类，Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作， 还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="排序操作：（均为static方法）"><a href="#排序操作：（均为static方法）" class="headerlink" title="排序操作：（均为static方法）"></a>排序操作：（均为static方法）</h3><ul>
<li><p>reverse(List)：反转 List 中元素的顺序 </p>
</li>
<li><p>shuffle(List)：对 List 集合元素进行随机排序 </p>
</li>
<li><p>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 </p>
</li>
<li><p>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 </p>
</li>
<li><p>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
</li>
</ul>
<h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><ul>
<li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 </p>
</li>
<li><p>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回 给定集合中的最大元素</p>
</li>
<li><p>Object min(Collection) </p>
</li>
<li><p>Object min(Collection，Comparator) </p>
</li>
<li><p>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 </p>
</li>
<li><p>void copy(List dest,List src)：将src中的内容复制到dest中 </p>
</li>
<li><p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
</li>
</ul>
<h3 id="同步控制方法"><a href="#同步控制方法" class="headerlink" title="同步控制方法"></a>同步控制方法</h3><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础之泛型</title>
    <url>/2020/06/28/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h1><h2 id="设计背景"><a href="#设计背景" class="headerlink" title="设计背景"></a>设计背景</h2><p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt; 这个就&lt;E&gt;是类型参数，即泛型。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如， 继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实 际的类型参数，也称为类型实参）。</p>
<p>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念， 允许我们在创建集合时指定集合元素的类型，正如：List&lt;String&gt;，这表明该List只能保存字符串类型的对象。</p>
<p>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</p>
<a id="more"></a>

<h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><ol>
<li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。 </li>
<li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li>
</ol>
<p><img src="E:\TanXY\Pictures\typora\Java基础之泛型\image-20200628145513962.png" alt="image-20200628145513962" style="zoom:80%;" /><img src="E:%5CTanXY%5CPictures%5Ctypora%5CJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%5Cimage-20200628145525503.png" alt="image-20200628145525503"></p>
<p><img src="E:%5CTanXY%5CPictures%5Ctypora%5CJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%5Cimage-20200628145525503.png" alt="image-20200628145525503"></p>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。</p>
<h1 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//类型推断</span></span><br><span class="line">list.add(<span class="number">78</span>);</span><br><span class="line">list.add(<span class="number">88</span>);</span><br><span class="line">list.add(<span class="number">77</span>);</span><br><span class="line">list.add(<span class="number">66</span>);</span><br><span class="line"><span class="comment">//遍历方式一：</span></span><br><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line"><span class="comment">//不需要强转</span></span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//遍历方式二：</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">"Tom1"</span>,<span class="number">34</span>);</span><br><span class="line">map.put(<span class="string">"Tom2"</span>,<span class="number">44</span>);</span><br><span class="line">map.put(<span class="string">"Tom3"</span>,<span class="number">33</span>);</span><br><span class="line">map.put(<span class="string">"Tom4"</span>,<span class="number">32</span>);</span><br><span class="line"><span class="comment">//添加失败</span></span><br><span class="line"><span class="comment">//map.put(33, "Tom");</span></span><br><span class="line">Set&lt;Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Entry&lt;String,Integer&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">  Entry&lt;String,Integer&gt; entry = iterator.next();</span><br><span class="line">  System.out.println(entry.getKey() + <span class="string">"---&gt;"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h1><ol>
<li><p>泛型的声明</p>
<p>interface List&lt;T&gt;和class GenTest&lt;K,V&gt;</p>
<p>其中T、K、V不代表值，而是代表类型，使用任意字母都可以。</p>
<p>常用T表示（Type）</p>
</li>
<li><p>泛型的实例化</p>
<p>一定要在类名后面指定类型参数的值（类型）。 如：<br>List&lt;String&gt; strList = new ArrayList&lt;String&gt;();<br>Iterator&lt;Customer&gt; iterator = customers.iterator();</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>T只能是类名，不能用基本数据类型填充，可以用包装类填充。</li>
<li><strong>把一个集合中的内容限制为一个特定的数据类型，这就是generics背后的核心思想</strong></li>
</ul>
<p>使用泛型的主要一个有点就是能够在编译时而不是在运行时检测错误。</p>
<h2 id="泛型类、泛型接口"><a href="#泛型类、泛型接口" class="headerlink" title="泛型类、泛型接口"></a>泛型类、泛型接口</h2><ol>
<li><p>泛型类堪忧多个参数，此时应将多个参数一起放到尖括号内，例如：&lt;E1,E2,E3&gt;</p>
</li>
<li><p>泛型类的构造器：public GenericClass(){}  错误写法：public GenericClass&lt;E&gt;(){}</p>
</li>
<li><p>实例化之后，操作原来泛型位置的结构必须与指定的泛型结构一致</p>
</li>
<li><p>泛型不同的引用不能互相赋值</p>
</li>
<li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价 于Object。</p>
<p>泛型要使用一路都用。要不用，一路都不要用。</p>
</li>
<li><p>jdk1.7，泛型的简化操作：ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();</p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类代替</p>
</li>
<li><p>不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity]; </p>
<p>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p>
</li>
<li><p>父类有泛型，子类可以选择保留泛型，也可以选择指定的泛型类型</p>
<p>子类不保留父类的泛型：按需实现，子类没有指定泛型类型的话，默认为Object</p>
<p>子类保留弗雷德泛型：泛型子类</p>
<p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</p>
<p>泛型方法格式：[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(T[] a, Collection&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (T o : a) &#123;</span><br><span class="line">    c.add(o);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Object[] ao = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  Collection&lt;Object&gt; co = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">  fromArrayToCollection(ao, co);</span><br><span class="line">  String[] sa = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br><span class="line">  Collection&lt;String&gt; cs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  fromArrayToCollection(sa, cs);</span><br><span class="line">  Collection&lt;Double&gt; cd = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 下面代码中T是Double类，但sa是String类型，编译错误。</span></span><br><span class="line">  <span class="comment">// fromArrayToCollection(sa, cd);</span></span><br><span class="line">  <span class="comment">// 下面代码中T是Object类型，sa是String类型，可以赋值成功。</span></span><br><span class="line">  fromArrayToCollection(sa, co);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Person&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">new</span> Person());</span><br><span class="line">    test(<span class="keyword">new</span> Man());</span><br><span class="line">    <span class="comment">//The method test(T) in the type PersonTest is not</span></span><br><span class="line">    <span class="comment">//applicable for the arguments (Creature)</span></span><br><span class="line">    test(<span class="keyword">new</span> Creature());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h1><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G&lt;B&gt;并不是G的子类型&lt;A&gt;</p>
<p>比如：String是Object的子类，但是List&lt;String&gt;并不是List&lt;Object&gt;的子类。</p>
<h1 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h1><ul>
<li><p>使用类型通配符：“？” </p>
<p>比如：List&lt;?&gt; ，Map&lt;?,?&gt; </p>
<p>List&lt;?&gt;是List&lt;String&gt;、List&lt;Object&gt;等各种泛型List的父类。</p>
</li>
<li><p>读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object。</p>
</li>
<li><p>不能向list写入元素，因为我们不知道c的元素类型，我们不能向其中添加对象，唯一的例外是null，它是所有类型的成员</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line">  list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">  <span class="comment">// list.add(3);//编译不通过</span></span><br><span class="line">  list.add(<span class="keyword">null</span>);</span><br><span class="line">  List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  List&lt;Integer&gt; l2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  l1.add(<span class="string">"123"</span>);</span><br><span class="line">  l2.add(<span class="number">15</span>);</span><br><span class="line">  read(l1);</span><br><span class="line">  read(l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>编译错误：不能用在泛型方法声明上，返回值类型前面的&lt;&gt;不能使用“?”，例如：</p>
<p>public static &lt;?&gt; void test(ArrayList list){}</p>
</li>
<li><p>编译错误：不能用在泛型类的声明上</p>
<p>class GenericTypeClass &lt;?&gt;{}</p>
</li>
<li><p>编译错误：不能用在创建对象上，右边属于创建集合对象</p>
<p>ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;();</p>
</li>
</ol>
<h2 id="有限制的通配符"><a href="#有限制的通配符" class="headerlink" title="有限制的通配符"></a>有限制的通配符</h2><ul>
<li><p>通配符指定上限 </p>
<p>上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= </p>
</li>
<li><p>通配符指定下限 </p>
<p>下限super：使用时指定的类型不能小于操作的类，即&gt;=</p>
</li>
<li><p>举例：</p>
<ul>
<li><p>&lt;? extends Number&gt;   (无穷小, Number]</p>
<p>只允许泛型为Number及Number子类的引用调用</p>
</li>
<li><p>&lt;? super Number&gt;   [Number, 无穷大)</p>
<p>只允许泛型为Number及其父类的引用调用</p>
</li>
<li><p>&lt;? entends Conparable&gt;</p>
<p>只允许泛型为实现Comparable接口的实现类的引用调用</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection3</span><span class="params">(Collection&lt;? extends Person&gt; coll)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? extends Person&gt;.why?</span></span><br><span class="line">  Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection4</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Person&gt; coll)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Iterator只能用Iterator&lt;?&gt;或Iterator&lt;? super Person&gt;.why?</span></span><br><span class="line">  Iterator&lt;?&gt; iterator = coll.iterator();</span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型嵌套举例"><a href="#泛型嵌套举例" class="headerlink" title="泛型嵌套举例"></a>泛型嵌套举例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt;();</span><br><span class="line">  ArrayList&lt;Citizen&gt; list = <span class="keyword">new</span> ArrayList&lt;Citizen&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Citizen(<span class="string">"刘恺威"</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Citizen(<span class="string">"杨幂"</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Citizen(<span class="string">"小糯米"</span>));</span><br><span class="line">  map.put(<span class="string">"刘恺威"</span>, list);</span><br><span class="line">  Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">  Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next();</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    ArrayList&lt;Citizen&gt; value = entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">"户主："</span> + key);</span><br><span class="line">    System.out.println(<span class="string">"家庭成员："</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的进程管理</title>
    <url>/2020/05/22/Linux%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>pa a    显示终端机下所有进程</p>
<p>ps -A   查看所有进程（ps -e和-A是一样的效果，-e更常用一点）（这两个看到的比上面那个多些）</p>
<p>ps u 以用户为主的格式来显示程序状况</p>
<p>ps x 显示所有程序，不以终端机来区分</p>
<p>lsof -i:端口号   根据指定的端口查询进程</p>
<p>常用的组合命令：</p>
<p>ps aux,然后再通过管道使用grep命令过滤查找特定的进程,然后再对特定的进程进行操作。</p>
<p><strong>ps -ef|grep java|grep -v grep</strong> 显示出所有的java进程，去处掉当前的grep进程。</p>
<h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>kill -9 进程PID      根据进程号结束进程</p>
<p>killall -9 进程名     根据进程名结束进程</p>
<blockquote>
<p>参考资料：<a href="https://blog.csdn.net/wojiaopanpan/article/details/7286430" target="_blank" rel="noopener">https://blog.csdn.net/wojiaopanpan/article/details/7286430</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统Apache2部署SSL证书</title>
    <url>/2020/04/25/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>本文档为您介绍了如何在Ubuntu系统以及Apache2中安装阿里云SSL证书。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>操作系统：Ubuntu</p>
<p>Web服务器：Apache 2</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ul>
<li>已从<a href="https://yundunnext.console.aliyun.com/?p=cas#/overview/cn-hangzhou" target="_blank" rel="noopener">SSL证书控制台</a>下载Apache服务器证书。</li>
<li>已安装Open SSL。</li>
</ul>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol>
<li><p>运行以下命令在apache2目录下创建ssl目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;etc&#x2F;apache2&#x2F;ssl</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令将下载的阿里云证书文件复制到ssl目录中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r YourDomainName_public.crt &#x2F;etc&#x2F;apache2&#x2F;ssl</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r YourDomainName_chain.crt &#x2F;etc&#x2F;apache2&#x2F;ssl</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r YourDomainName.key &#x2F;etc&#x2F;apache2&#x2F;ssl</span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>运行以下命令启用SSL模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo a2enmod ssl</span><br></pre></td></tr></table></figure>

<p><img src="https://blog.steventan.top/images/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/znDyZLWRAsv2f4t.png" alt="image.png"></p>
<p>SSL模块启用后可执行<code>ls /etc/apache2/sites-available</code>查看目录下生成的default-ssl.conf文件。</p>
<p><strong>说明：</strong> 443端口是网络浏览端口，主要用于HTTPS服务。SSL模块启用后会自动放行443端口。若443端口未自动放行，可执行<code>vi /etc/apache2/ports.conf</code>并添加<code>Listen 443</code>手动放行。</p>
</li>
<li><p>运行以下命令修改SSL配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;YourDomainName-ssl.conf</span><br></pre></td></tr></table></figure>

<p>在default-ssl.conf文件中找到以下参数进行修改后保存并退出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;IfModules mod_ssl.c&gt;</span><br><span class="line">&lt;VirtualHost *:443&gt;  </span><br><span class="line">ServerName   <span class="comment">#修改为证书绑定的域名www.YourDomainName.com。</span></span><br><span class="line">SSLCertificateFile /etc/apache2/ssl/www.YourDomainName_public.crt   </span><br><span class="line"><span class="comment">#将/etc/apache2/ssl/www.YourDomainName.com_public.crt替换为证书文件路径+证书文件名。</span></span><br><span class="line">SSLCertificateKeyFile /etc/ssl/apache2/www.YourDomainName.com.key   </span><br><span class="line"><span class="comment">#将/etc/apache2/ssl/www.YourDomainName.com.key替换为证书秘钥文件路径+证书秘钥文件名。</span></span><br><span class="line">SSLCertificateChainFile /etc/apache2/ssl/www.YourDomainName.com_chain.crt  </span><br><span class="line"><span class="comment">#将/etc/apache2/ssl/www.YourDomainName.com_chain.crt替换为证书链文件路径+证书链文件名。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://blog.steventan.top/images/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/XESFU87K4QfY92A.png" alt="image.png"></p>
<p>/sites-available：该目录存放的是可用的虚拟主机；/sites-enabled：该目录存放的是已经启用的虚拟主机。</p>
<p><strong>说明：</strong> default-ssl.conf文件可能存放在/etc/apache2/sites-available或/etc/apache2/sites-enabled目录中。</p>
</li>
<li><p>运行以下命令把default-ssl.conf映射至/etc/apache2/sites-enabled文件夹中建立软链接、实现二者之间的自动关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;YourDomainName-ssl.conf &#x2F;etc&#x2F;apache2&#x2F;sites-enabled&#x2F;YourDomainName-ssl.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令重新加载Apache 2配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;apache2 force-reload</span><br></pre></td></tr></table></figure>

<p><img src="https://blog.steventan.top/images/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/4Rn27NQuZgTDoFK.png" alt="image.png"></p>
</li>
<li><p>运行以下命令重启Apache 2服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;apache2 restart</span><br></pre></td></tr></table></figure>

<p><img src="https://blog.steventan.top/images/Ubuntu%E7%B3%BB%E7%BB%9FApache2%E9%83%A8%E7%BD%B2SSL%E8%AF%81%E4%B9%A6/13p6Xtfh49s8VQi.png" alt="image.png"></p>
</li>
</ol>
<h2 id="后续操作"><a href="#后续操作" class="headerlink" title="后续操作"></a>后续操作</h2><p>Apache 2服务重启成功后，您可在浏览器中输入<a href="https://www.YourDomainName.com验证证书安装结果。浏览器地址栏显示绿色的小锁标识说明证书安装成功。" target="_blank" rel="noopener">https://www.YourDomainName.com验证证书安装结果。浏览器地址栏显示绿色的小锁标识说明证书安装成功。</a></p>
<p><a href="https://help.aliyun.com/document_detail/102450.html?spm=a2c4g.11186623.2.16.641a5d990B7ZJl#title-8vo-dzo-1in" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java枚举类</title>
    <url>/2020/06/16/Java%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>在JDK5.0之前需要自定义枚举类，JDK5.0中新增了enum关键字，用来定义枚举类</p>
<h2 id="枚举类的特点"><a href="#枚举类的特点" class="headerlink" title="枚举类的特点"></a>枚举类的特点</h2><ul>
<li>枚举类对象的属性不允许被改动，所以应该使用private final修饰</li>
<li>枚举类的被private final修饰的属性要在构造器中为期赋值</li>
<li>若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须传入对应参数</li>
</ul>
<h1 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h1><ol>
<li>私有化类的构造器，保证不能再类的外部创建其对象</li>
<li>在类的内部穿件枚举类的实例，并用public static final修饰</li>
<li>对象如果有实例变量，应该声明为private final，并在构造器中初始化</li>
</ol>
<a id="more"></a>

<p>用季节来举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String NAME;<span class="comment">//季节的名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String DESC;<span class="comment">//季节的描述</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.NAME = seasonName;</span><br><span class="line">    <span class="keyword">this</span>.DESC = seasonDesc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">"春天"</span>, <span class="string">"春暖花开"</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">"夏天"</span>, <span class="string">"夏日炎炎"</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">"秋天"</span>, <span class="string">"秋高气爽"</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">"冬天"</span>, <span class="string">"白雪皑皑"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="enum关键字定义枚举类"><a href="#enum关键字定义枚举类" class="headerlink" title="enum关键字定义枚举类"></a>enum关键字定义枚举类</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>用enum定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类</li>
<li>枚举类的构造器只能用private修饰</li>
<li>枚举类的所有实例必须在枚举类中显式列出（用“,”分隔，“;”）结尾，列出的实例会自动添加public static final修饰</li>
<li>必须要在枚举类的第一行声明枚举类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum &#123;</span><br><span class="line">  SPRING(<span class="string">"春天"</span>,<span class="string">"春风又绿江南岸"</span>),</span><br><span class="line">  SUMMER(<span class="string">"夏天"</span>,<span class="string">"映日荷花别样红"</span>),</span><br><span class="line">  AUTUMN(<span class="string">"秋天"</span>,<span class="string">"秋水共长天一色"</span>),</span><br><span class="line">  WINTER(<span class="string">"冬天"</span>,<span class="string">"窗含西岭千秋雪"</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">    <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seasonName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seasonDesc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h1><ul>
<li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 </li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。 </li>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中常用的函数</title>
    <url>/2020/04/26/MySQL%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ol>
<li><p>合并字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">concat();</span><br><span class="line">concat(&quot;Hello&quot;,&quot; World&quot;);#Hello world，当传入的参数又一个为null时结果为null</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">length(str);#空格也算一个字符，计算的是字节的长度，一个汉字占两个字节</span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>字母大小写转换函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upper();#将传入的字符全部转换为大写</span><br><span class="line">lower();#将传入的字符全部转换为小写</span><br></pre></td></tr></table></figure>
</li>
<li><p>在字符串中查找字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate(str1,str);# 返回str中字符串str1的开始位置</span><br><span class="line">position(str1 IN str);# 返回str中字符串str1的开始位置</span><br><span class="line">instr(str,str1); # 返回str中字符串str1的开始位置</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left(str,num);# 从左边截取,字符串是str,长度是num</span><br><span class="line">right(str,num);# 从右边截取,字符串是str,长度是num</span><br><span class="line">substring(str,num,len);# 字符串是str,从num位置开始,长度是len,包含num位置</span><br><span class="line">mid(str,num,len);# 字符串是str,从num位置开始,长度是len,包含num位置</span><br></pre></td></tr></table></figure>
</li>
<li><p>去掉字符串首位空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ltrim(str);# 去除字符串开始的空格</span><br><span class="line">rtrim(str);# 去除字符串后面的空格</span><br><span class="line">trim(str);# 去除字符串首位的空格</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replace(str1,str2,str3);# str1是原字符串，str2是需要替换的字符串，str3是替换str2的字符串</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><ol>
<li><p>获取随机数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RAND();# 返回的数完全随机</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取整数的函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CEIL(num);# 上取整</span><br><span class="line"></span><br><span class="line">FLOOR(num);# 下取整</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取数值函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRUNCATE(x,y);#x表示要截取的数值,y表示小数点后几位,也就是保留几位小数,是直接舍去,而不是四舍五入.</span><br></pre></td></tr></table></figure>
</li>
<li><p>四舍五入函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROUND(x);</span><br><span class="line">ROUND(x,y);# 返回数值x保留到小数点后y位</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数:"></a>日期函数:</h2><ol>
<li><p>获取当前日期和时间函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">now();# 当前日期和时间</span><br><span class="line">locatime();# 当前日期和时间</span><br><span class="line">current_timestamp();# 当前日期和时间</span><br><span class="line">SYSDTAE();# 当前日期和时间</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前日期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curdate();# 当前日期</span><br><span class="line">current_date();# 当前日期</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curtime();</span><br><span class="line">current_time();</span><br></pre></td></tr></table></figure>
</li>
<li><p>各种方式显示日期和时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix_timestamp(日期类型的字符串);# 将日期类型的字符串转化为整形(秒数),UNIX格式</span><br><span class="line">from_unixtime(&quot;整形&quot;);# 将整形字符串转化为日期,普通格式</span><br><span class="line">UTC_DATE();# utc日期,只有日期</span><br><span class="line">UTC_TIME();# utc时间 ,只有时间</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取日期和时间各部分值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW() 当前日期和时间,</span><br><span class="line">YEAR(NOW()) 年,</span><br><span class="line">QUARTER(NOW()) 季度,</span><br><span class="line">MONTH(NOW()) 月,</span><br><span class="line">WEEK(NOW())星期,</span><br><span class="line">DAYOFMONTH(NOW()) 天,</span><br><span class="line">HOUR(NOW()) 小时,</span><br><span class="line">MINUTE(NOW()) 分,</span><br><span class="line">SECOND(NOW()) 秒;</span><br></pre></td></tr></table></figure>
</li>
<li><p>月(参数都是日期类型的字符串)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MONTH(date);</span><br><span class="line">MONTHNAME(date);</span><br></pre></td></tr></table></figure>
</li>
<li><p>星期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">week(date);# 年中第几个星期</span><br><span class="line">weekofyear(date);# 年中第几个星期</span><br><span class="line">dayname(date);# 星期,英文显示</span><br><span class="line">dayofweek(date);# 星期(不理解,用下面的)</span><br><span class="line">weekday(date);# 星期,数字表示</span><br></pre></td></tr></table></figure>
</li>
<li><p>天</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dayofyear(date);# 年中的第几天</span><br><span class="line">dayofmonth(date);# 月中的第几天</span><br></pre></td></tr></table></figure>
</li>
<li><p>EXTRACT函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXTRACT(YEAR from NOW()); # 年</span><br><span class="line">EXTRACT(month from NOW()); # 月</span><br><span class="line">EXTRACT(day from NOW()); # 日</span><br><span class="line">EXTRACT(hour from NOW()); # 时</span><br><span class="line">EXTRACT(minutefrom NOW()); # 分</span><br><span class="line">EXTRACT(second from NOW()); # 秒</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算日期和时间的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT NOW() 当前日期和时间,</span><br><span class="line">TO_DAYS(NOW()) 相隔天数, # 距离0000年1月1日</span><br><span class="line">FROM_DAYS(TO_DAYS(NOW())) 一段时间后日期和时间,</span><br><span class="line">DATEDIFF(NOW(),&#39;2000-12-01&#39;) 相隔天数;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与指定日期和时间操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADDDATE(date,n); # 计算date加上n天后的日期</span><br><span class="line">SUBDATE(date,n); # 计算date减去n天后的日期</span><br><span class="line">ADDDATE(d,INTERVAL expr type);# type的类型查看#http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;sql&#x2F;func_date_add.asp</span><br><span class="line">SUBDATE(d,INTERVAL expr type);</span><br><span class="line"># 例子</span><br><span class="line">select adddate(now(),interval &#39;2,3&#39; year_month ) &#39;2年3个月后的日期&#39;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中设置http强制重定向为https</title>
    <url>/2020/04/25/http%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%BAhttps/</url>
    <content><![CDATA[<h3 id="1-开启重定向"><a href="#1-开启重定向" class="headerlink" title="1.开启重定向"></a>1.开启重定向</h3><p>a2enmod rewrite</p>
<h3 id="2-设置http端口重定向"><a href="#2-设置http端口重定向" class="headerlink" title="2.设置http端口重定向"></a>2.设置http端口重定向</h3><p>将下面这段放到要重定向的站点配置文件里面，放在&lt;\VirtualHost *:80&gt;&lt;\VirtualHost&gt; 标签内的任何位置都行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond  %&#123;HTTPS&#125; !=on</span><br><span class="line">RewriteRule  ^(.*)  https://%&#123;SERVER_NAME&#125;<span class="variable">$1</span> [L,R]</span><br></pre></td></tr></table></figure>

<h3 id="重启apach2"><a href="#重启apach2" class="headerlink" title="重启apach2"></a>重启apach2</h3><p>service apache2 restart</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo一键部署到云服务器</title>
    <url>/2020/03/01/hexo%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>&emsp;&emsp;之前折腾了好久，用Rsync，ftp，stfp都试过了，都没弄成，在网上看的教程很多也是基于git的，也就是在服务器建一个git的钩子，指定一个目录作为远程仓库地址，可以通过ssh连接，然后在本地可以直接上传，最后才选择的这个方案。在成功之前踩了好多坑，配sftp的时候用百度上的坑爹教程，导致服务器都连不上，最后还是选择则了用git做仓库的方式来上传，这个教程很简单，相对于其他的同样的方法，只是不知道会不会有安全问题。</p>
</blockquote>
<h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><h3 id="1-配置Git-hooks"><a href="#1-配置Git-hooks" class="headerlink" title="1. 配置Git hooks"></a>1. 配置Git hooks</h3><ol>
<li><p>创建Git裸仓库</p>
<p>blog.git作为远程Git仓库，Hexo在本地生成的博客静态文件可以通过push与其同步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/blog.git &amp;&amp; <span class="built_in">cd</span> ~/blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">2. 在hooks目录下新建一个脚本文件&#96;post-receive&#96;</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96; bash</span><br><span class="line">   touch hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure>

<p><code>post-receive</code>脚本将在blog.git仓库接收到push时执行</p>
<p>脚本非常简单，就是删除原有的/var/www/html/blog目录，然后从blog.git仓库clone新的博客静态文件</p>
<p><code>vim hooks/post-receive</code> 将下面内容写入<code>post-receive</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line">rm -rf /var/www/html/blog</span><br><span class="line">git <span class="built_in">clone</span> /root/blog.git /var/www/html/blog</span><br></pre></td></tr></table></figure>
</li>
<li><p>给post-receive脚本执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x hooks/post-receive</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置好之后可以测试一下，就在本地clone那个远程仓库</p>
</li>
</ol>
<h3 id="2-修改hexo配置文件"><a href="#2-修改hexo配置文件" class="headerlink" title="2.修改hexo配置文件"></a>2.修改hexo配置文件</h3><p>修改hexo根目录下的_config.yml文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">'git'</span></span><br><span class="line">  repo: <span class="string">'root@服务器IP:blog.git'</span></span><br></pre></td></tr></table></figure>

<h3 id="补充一点"><a href="#补充一点" class="headerlink" title="补充一点"></a>补充一点</h3><p>如果之前有在同一台服务器上配置过git的裸库，需要在用户目录的<code>.ssh</code>目录下，将<code>known_hosts</code>文件中的主机记录删除掉，否则可能会报错。</p>
<img src="https://i.loli.net/2020/04/25/Nk1QSac4IE2TxRz.png" alt="image.png" style="zoom:80%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;这个方法和其他复杂一点的方法区别就是，没有专门建一个git的用户用来上传，就直接用root用户上传，就自己用的话应该问题也不大🤔</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git的基本使用</title>
    <url>/2020/03/14/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<img src="https://blog.steventan.top/images/git的基本使用/HjQNKBory3xwiJv.jpg" alt="git.jpg" style="zoom:50%;" />

<blockquote>
<p>git是一个前几年兴起的很好用的版本管理工具，用了半年多了体验还是很不错了，也是现在比较主流的版本管理工具。现在分享一下git的基操，但是最好是要理解好这些命令的作用，否则后果可能很严重（手动滑稽），我自己就有过这样的经历。另外，最好是有Linux的命令基础，没有的话理解起来很吃力。</p>
</blockquote>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="配置全局的邮箱和用户名"><a href="#配置全局的邮箱和用户名" class="headerlink" title="配置全局的邮箱和用户名"></a>配置全局的邮箱和用户名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name=<span class="string">"云代码托管平台（github、gitlab或者gitee）的用户名"</span></span><br><span class="line">git config --global user.email=<span class="string">"注册的邮箱"</span></span><br></pre></td></tr></table></figure>

<p>这个也可以在c盘用户的根目录下面打开<code>.gitconfig</code>文件进行配置</p>
<a id="more"></a>

<img src="https://blog.steventan.top/images/git的基本使用/mbg5o7HP3jOErcf.png" alt="image.png" style="zoom: 50%;" />

<img src="https://blog.steventan.top/images/git的基本使用/Wy3QFZUBHwsOLcJ.png" alt="image.png" style="zoom: 50%;" />

<p><strong>命令里面不加global就只是对当前仓库的配置</strong></p>
<h3 id="生成ssh秘钥对"><a href="#生成ssh秘钥对" class="headerlink" title="生成ssh秘钥对"></a>生成ssh秘钥对</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f 秘钥名称 -C <span class="string">'注册邮箱'</span></span><br></pre></td></tr></table></figure>

<p>在用户根目录下会生成一个.ssh的文件夹</p>
<p>开始里面会有两个文件,后缀是<code>.pub</code>的是公钥,另一个是私钥</p>
<img src="https://blog.steventan.top/images/git的基本使用/FWH2QwClGYJgdpt.png" alt="image.png" style="zoom: 50%;" />

<p>用记事本或者其他的编辑器打开这个文件，复制其全部内容，以GitHub为例：点击<code>new ssh key</code></p>
<p><img src="https://blog.steventan.top/images/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/mEh4VgXdPOrCbkx.png" alt=""></p>
<p>将其粘贴到Key的框框中，手动打码（嘿嘿嘿），然后点击add ssh key就大功告成了</p>
<p><img src="https://blog.steventan.top/images/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/y25IoJunEg41TXW.png" alt=""></p>
<p>然后在git bash中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p><img src="https://blog.steventan.top/images/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/PE3MsvfSURqHyc2.png" alt=""></p>
<p>如果是这样就表示，添加成功了（只要GitHub上没提示有问题，其实一般都没有问题，这一步可以跳过）</p>
<h2 id="git上传GitHub的基本步骤"><a href="#git上传GitHub的基本步骤" class="headerlink" title="git上传GitHub的基本步骤"></a>git上传GitHub的基本步骤</h2><h3 id="第一步、创建一个仓库或者clone一个仓库"><a href="#第一步、创建一个仓库或者clone一个仓库" class="headerlink" title="第一步、创建一个仓库或者clone一个仓库"></a>第一步、创建一个仓库或者clone一个仓库</h3><p>从远程仓库clone项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure>

<p>clone下来的项目会包含版本信息不用再初始化了，直接可以进入第二步</p>
<p>在本地创建git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>这个命令的作用就是初始化一个git的版本管理仓库</p>
<p>执行完这个命令之后，git bash当前所在的文件夹下面会生成一个.git的文件夹</p>
<p>初始化完之后就可以在这个文件夹下面写项目了，写完项目之后↓</p>
<h3 id="第二步、将文件添加到索引中"><a href="#第二步、将文件添加到索引中" class="headerlink" title="第二步、将文件添加到索引中"></a>第二步、将文件添加到索引中</h3><p>将git bash当前所在文件夹下面的所有文件添加到索引中，除了被忽略的（gitignore又有另外一套学问，在这里不详细说了）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p><code>.</code>表示当前文件夹下面的所有文件和文件夹，但是踩过一个坑，<strong>git不会将空文件夹加入索引</strong>，要添加就要在那个空文件夹下面随便放一个文件可以是<code>.gitignore</code></p>
<p>可以参考对应的官方文档：<img src="https://blog.steventan.top/images/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/QDTdRA357Sqz8Jo.png" alt=""></p>
<h3 id="第三步、将索引中的文件提交到本地的版本库"><a href="#第三步、将索引中的文件提交到本地的版本库" class="headerlink" title="第三步、将索引中的文件提交到本地的版本库"></a>第三步、将索引中的文件提交到本地的版本库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m<span class="string">'提交的信息'</span></span><br></pre></td></tr></table></figure>

<p>引号里面一般是写这次提交修复了什么问题，或者增加了什么功能</p>
<h3 id="第四步、添加远程仓库地址"><a href="#第四步、添加远程仓库地址" class="headerlink" title="第四步、添加远程仓库地址"></a>第四步、添加远程仓库地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add 远程仓库在本地的名字 远程仓库地址</span><br></pre></td></tr></table></figure>

<p>远程仓库在本地的名字随便取什么都行，不知道取什么名字的话就origin吧</p>
<p>远程仓库的地址打开github的页面复制 </p>
<img src="https://blog.steventan.top/images/git的基本使用/cINP5TOfSA2Qo83.png" alt="image.png" style="zoom:50%;" />

<h3 id="第五步、从远程仓库同步版本库信息"><a href="#第五步、从远程仓库同步版本库信息" class="headerlink" title="第五步、从远程仓库同步版本库信息"></a>第五步、从远程仓库同步版本库信息</h3><p><strong>如果是第一次建立仓库，远程仓库没有东西，可以跳过这步</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull 上一步自己给远程仓库取得名字 分支名</span><br></pre></td></tr></table></figure>

<p>每次pull之前一定要进行前面三步（2-4步），要不然你pull之前改的代码可能就全没了，白改了</p>
<p>这一步也最好放在改代码之前就进行，那么久可以不用进行前面三步了</p>
<h3 id="第六步、将本地版本库的信息提交到远程仓库"><a href="#第六步、将本地版本库的信息提交到远程仓库" class="headerlink" title="第六步、将本地版本库的信息提交到远程仓库"></a>第六步、将本地版本库的信息提交到远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push 上上一步自己给远程仓库取得名字 分支名</span><br></pre></td></tr></table></figure>

<p>上传到远程仓库的分支本地也一定要有，否则则会报错</p>
<p>如果没创建分支的话，默认就只有一个master分支</p>
<h2 id="git的版本管理"><a href="#git的版本管理" class="headerlink" title="git的版本管理"></a>git的版本管理</h2><p>查看提交过的历史信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>回滚到之前的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本哈希值</span><br></pre></td></tr></table></figure>

<p>举个栗子：</p>
<img src="https://blog.steventan.top/images/git的基本使用/aDfrmI7inANe14X.png" alt="image.png" style="zoom:67%;" />



<blockquote>
<p>如果你看到了这里，最后再看点东西吧，新人可能会分不清GitHub和git，说一下这个问题。</p>
<p>GitHub就是GitHub，git就是git，这是两个东西。非要说联系的话就是GitHub是基于git的云版本管理仓库，可以很多人一起用一个仓库开发，这就是多人协作，也可以把它当做代码的备份仓库，现在GitHub的私有仓库免费了，可以试试。GitHub和GitLab或者国内的gitee都是差不多的东西，都是基于git的云代码管理仓库。而git就是一个本地的版本控制软件，每次改完代码之后都可以commit提交到本地的版本库，如果哪次改错了很多东西，也改不回去了，这个时候git就派上用场了，可以用git回滚到之前commit过的一个版本。其实git还有很多其他的强大功能，留到下一篇再讲。</p>
<p>还有什么其他问题可以发邮箱给我哦！</p>
<p><a href="mailto:steventanxy@foxmail.com">steventanxy@foxmail.com</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime text3下载插件</title>
    <url>/2020/02/26/sublime%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h5 id="1-在github上下载Package-Control的安装包"><a href="#1-在github上下载Package-Control的安装包" class="headerlink" title="1.在github上下载Package Control的安装包"></a>1.在github上下载Package Control的安装包</h5><p><a href="https://github.com/wbond/sublime_package_control" target="_blank" rel="noopener">https://github.com/wbond/sublime_package_control</a> </p>
<h5 id="2-打开sublime存放插件的目录：在sublime菜单栏-gt-gt-首选项-gt-gt-浏览插件"><a href="#2-打开sublime存放插件的目录：在sublime菜单栏-gt-gt-首选项-gt-gt-浏览插件" class="headerlink" title="2.打开sublime存放插件的目录：在sublime菜单栏&gt;&gt;首选项&gt;&gt;浏览插件"></a>2.打开sublime存放插件的目录：在sublime菜单栏&gt;&gt;首选项&gt;&gt;浏览插件</h5><a id="more"></a>

<img src="https://blog.steventan.top/images/sublime下载插件/image-20200428221639527.png" alt="image-20200428221639527" style="zoom:67%;" />

<p>找到下载的文件，解压，将文件夹重命名为“Package Control”复制到sublime存放插件的目录</p>
<h5 id="3-https-packagecontrol-io-这个被墙了-下载插件不下来，把下载链接改为国内的"><a href="#3-https-packagecontrol-io-这个被墙了-下载插件不下来，把下载链接改为国内的" class="headerlink" title="3.https://packagecontrol.io 这个被墙了 下载插件不下来，把下载链接改为国内的."></a>3.<code>https://packagecontrol.io</code> 这个被墙了 下载插件不下来，把下载链接改为国内的.</h5><p><img src="https://blog.steventan.top/images/sublime%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6/LGq7aPkejfiBXRz.png" alt="qwqwd.png"></p>
<p>修改User文件下的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"bootstrapped"</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="string">"channels"</span>:</span><br><span class="line"> [</span><br><span class="line">  <span class="string">"https://erhan.in/channel_v3.json"</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="string">"in_process_packages"</span>:</span><br><span class="line"> [</span><br><span class="line"> ],</span><br><span class="line"> <span class="string">"installed_packages"</span>:</span><br><span class="line"> [</span><br><span class="line">  <span class="string">"ChineseLocalizations"</span>,</span><br><span class="line">  <span class="string">"Package Control"</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-重启sublime-text3"><a href="#4-重启sublime-text3" class="headerlink" title="4.重启sublime text3"></a>4.重启sublime text3</h5>]]></content>
      <categories>
        <category>软件</category>
        <category>配置</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ Idea配置类和方法的注释模板</title>
    <url>/2020/04/15/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="设置类的注释模板"><a href="#设置类的注释模板" class="headerlink" title="设置类的注释模板"></a>设置类的注释模板</h2><p><img src="https://blog.steventan.top/images/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/SZLA4oF5vn3hMyG.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> $&#123;USER&#125;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Create</span> $&#123;DATE&#125; - $&#123;TIME&#125;</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="设置方法的注释模板"><a href="#设置方法的注释模板" class="headerlink" title="设置方法的注释模板"></a>设置方法的注释模板</h2><ol>
<li><p><img src="https://blog.steventan.top/images/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/xjalmy8dg3Y5WtQ.png" alt="image.png"></p>
<p>也可以选2，先新建一个模板组，而这里是直接选的已经有得user组，然后添加template</p>
</li>
<li><p>根据自己的习惯给模板取个名字，填在Abbreviation里面</p>
<p><strong>模板里面开头是没有/的</strong>，加上斜杠如果在方法体外写注释，变量名和返回值类型获取不到显示是空白的</p>
</li>
<li><p>点下面的define设置模板生成的地方，选择java下面的所有，或者选everywhere也行</p>
<p><img src="https://blog.steventan.top/images/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/TmfWIo75LX3dqcQ.png" alt=""></p>
</li>
<li><p>右下角的expand with是模板补全的按键，可以根据自己的习惯改一下</p>
</li>
<li><p>把模板贴到文本框里面之后就可以点Edit variables了</p>
<p><img src="https://blog.steventan.top/images/idea%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/U8CyvX5ElThioqa.png" alt="image.png"></p>
</li>
<li><p>保存之后可以再一个方法前面/** + 回车就行了，这就是为什么我名字取为**</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * <span class="meta">@Author</span> $USER$</span><br><span class="line"> * <span class="meta">@Description</span> $description$</span><br><span class="line"> * <span class="meta">@Date</span> $date$ $time$</span><br><span class="line"> * <span class="meta">@Param</span> $param$</span><br><span class="line"> * <span class="meta">@return</span> $<span class="keyword">return</span>$</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件</category>
        <category>配置</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot在IDEA中的热部署</title>
    <url>/2020/03/15/spring-boot%E5%9C%A8IDEA%E4%B8%AD%E7%9A%84%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote>
<p>热部署用起来真的很爽，节约了开发的时间，让开发调试事半功倍，下面就来介绍一下热部署在idea中的热部署</p>
</blockquote>
<a id="more"></a>

<h2 id="开启idea的自动编译"><a href="#开启idea的自动编译" class="headerlink" title="开启idea的自动编译"></a>开启idea的自动编译</h2><p>打开顶部工具栏 File -&gt; Settings -&gt; Default Settings -&gt; Build -&gt; Compiler 然后勾选 Build project automatically </p>
<p><img src="https://i.loli.net/2020/04/01/VHKm5DiQIF1cwTs.png" alt="image.png"></p>
<h2 id="开启idea的热部署策略"><a href="#开启idea的热部署策略" class="headerlink" title="开启idea的热部署策略"></a>开启idea的热部署策略</h2><p>顶部菜单- &gt;Edit Configurations-&gt;SpringBoot插件-&gt;目标项目-&gt;勾选热更新</p>
<p><img src="https://i.loli.net/2020/04/01/DFohgObmEYvM8In.png" alt="image.png"></p>
<h2 id="在项目中添加热部署插件"><a href="#在项目中添加热部署插件" class="headerlink" title="在项目中添加热部署插件"></a>在项目中添加热部署插件</h2><p>在pom文件中加入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>配置完之后，静态文件有改变直接在浏览器中刷新就能看见效果了，不用再等待项目的重新启动了，自从用了热部署之后就在也离不开了﻿ ε≡٩(๑&gt;₃&lt;)۶</p>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
        <category>配置</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的基本使用</title>
    <url>/2020/03/28/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://blog.steventan.top/images/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/z6JqkpsQT2orBhE.png" alt="docker.jpg"></p>
<blockquote>
<p>前几天学了一下docker，一方面是记录一下这些命令，另一方面为了复习一下，所以写了下面这些！有什么问题还请指正！</p>
</blockquote>
<h2 id="在Linux中下载docker"><a href="#在Linux中下载docker" class="headerlink" title="在Linux中下载docker"></a>在Linux中下载docker</h2><p>CentOS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure>

<p>ubunte</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure>

<blockquote>
<p>找不到包的话update一下</p>
<p>CentOS<code>yum update</code></p>
<p>Ubuntu<code>apt-get update</code></p>
</blockquote>
<a id="more"></a>

<h2 id="更换docker镜像源"><a href="#更换docker镜像源" class="headerlink" title="更换docker镜像源"></a>更换docker镜像源</h2><p>在<code>/etc/docker/</code> 目录下修改或者新建<code>daemon.json</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Docker国内其他源：</p>
<p>Docker 官方中国区</p>
<p><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></p>
<p>网易</p>
<p><a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a></p>
<p>中国科技大学</p>
<p><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></p>
<p>阿里云的源需要注册，我没有去折腾</p>
<h2 id="镜像相关的命令"><a href="#镜像相关的命令" class="headerlink" title="镜像相关的命令"></a>镜像相关的命令</h2><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search 镜像名</span><br></pre></td></tr></table></figure>

<p>这个没什么好说的，就是根据你给出的镜像名列出仓库中有的相关的镜像 </p>
<p>可以加条件 -s star数</p>
<p>比如<code>docker search -s 50 mysql</code>就是star数在50K以上的镜像才会被列出来</p>
<p>等于就是增加搜索的条件，还有其他的参数可以自己查</p>
<h3 id="从仓库pull镜像"><a href="#从仓库pull镜像" class="headerlink" title="从仓库pull镜像"></a>从仓库pull镜像</h3><p>这个命令就和git的pull差不多意思，git pull拉的是代码；docker pull拉的是镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名:版本号</span><br><span class="line">版本号不写默认就是latest，最新的</span><br></pre></td></tr></table></figure>

<p>比如拉MySQL的镜像：<code>docker pull mysql</code></p>
<h3 id="删除一个镜像"><a href="#删除一个镜像" class="headerlink" title="删除一个镜像"></a>删除一个镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像名或ID</span><br></pre></td></tr></table></figure>

<h3 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h3><blockquote>
<p>将镜像打包，方便移植到其他设备运行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o 打包后的名字.tar 镜像名</span><br></pre></td></tr></table></figure>

<h3 id="导入打包的镜像"><a href="#导入打包的镜像" class="headerlink" title="导入打包的镜像"></a>导入打包的镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load &lt; 包名</span><br></pre></td></tr></table></figure>



<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="由镜像创建一个容器并运行"><a href="#由镜像创建一个容器并运行" class="headerlink" title="由镜像创建一个容器并运行"></a>由镜像创建一个容器并运行</h3><p>这里就以mysql为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=mysql -p 3306:3306 -e   MYSQL_ROOT_PASSWORD=123456 mysql --lower_case_table_names=1</span><br></pre></td></tr></table></figure>

<p>mysql的参数比较多一点</p>
<blockquote>
<p>-d表示后台运行</p>
<p>-i表示交互式的操作（我也不太明白什么意思，后面弄明白了再更新）</p>
<p>–name是给生成的容器取名字</p>
<p>-p是端口的映射，冒号前面的是宿主机的端口，后面的是容器中的端口，意思就是容器中3306的端口映射到宿主机的3306端口，直接访问宿主机的3306端口就可以访问到docker中的MySQL。如果要在宿主机直接连接MySQL，可以ip a看一下docker的在宿主机的ip，然后通过那个ip的3306端口就可以访问了</p>
<p>MYSQL_ROOT_PASSWORD 这个是这只mysql的root用户密码</p>
<p>–lower_case_table_names=1 这个是不区分表的大小写，当初就是应为这个才入了docker的坑，直接在服务装的MySQL打死改不了这个大小写不敏感，一个项目里面刚好有有很多表是大写，数据库里面是小写的，我就是不想改成小写（傲娇脸），然后折腾几天都没能改好，后来就考虑了docker。在Windows下运行没问题，因为Windows本来就不区分大小写，到Linux下面就区分大小写了，项目部署 好久，都没能跑起来，报错找不到表，我当时还莫名其妙，明明有这个表怎么找不到呢，后来发现了这个坑。</p>
</blockquote>
<p>运行Tomcat就简单些：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -dp 8080:8080 tomcat镜像ID</span><br></pre></td></tr></table></figure>

<p>上面都是在后台运行的，如果想要直接在</p>
<h3 id="停止容器的运行"><a href="#停止容器的运行" class="headerlink" title="停止容器的运行"></a>停止容器的运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop 容器名</span><br></pre></td></tr></table></figure>

<h3 id="启动创建的镜像"><a href="#启动创建的镜像" class="headerlink" title="启动创建的镜像"></a>启动创建的镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start 容器名</span><br></pre></td></tr></table></figure>

<p><strong>重启就是restart啦</strong></p>
<h3 id="进入到容器中"><a href="#进入到容器中" class="headerlink" title="进入到容器中"></a>进入到容器中</h3><blockquote>
<p>一个容器其实就是一个小的Linux环境，但是做了很多精简，只保留了必要的部分</p>
</blockquote>
<p>有两种方式：</p>
<p>第一种：<code>docker attach 容器名字或者ID</code></p>
<p>第二种：<code>docker exec -it 容器名或ID /bin/bash</code></p>
<p>这两个的区别，如果第一种方式进去在exit，那会退出并且停止容器的运行，第二种exit不会停止运行</p>
<h3 id="删除一个容器"><a href="#删除一个容器" class="headerlink" title="删除一个容器"></a>删除一个容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm 容器名或ID</span><br></pre></td></tr></table></figure>

<h3 id="由容器创建一个镜像"><a href="#由容器创建一个镜像" class="headerlink" title="由容器创建一个镜像"></a>由容器创建一个镜像</h3><blockquote>
<p>你从远程仓库拉的默认镜像，经过个性化的配置之后，就可以这样创建一个自己的镜像，然后在把镜像打包成压缩包，传到其他设备，导入之后就又可以在其他设备运行了</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -a 这个镜像的作者 -m 提交时候的文字说明 容器名 创建的镜像名</span><br></pre></td></tr></table></figure>

<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>

<p>什么都不加就只会列出当前正在运行的容器</p>
<p>加上<code>-a</code>是列出所有的镜像，<code>-q</code>表示静默模式，只显示容器编号</p>
<p><code>docker rm (docker ps -aq)</code>这个组合命令就是删除所有的容器</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>八路抢答器课程设计报告</title>
    <url>/2020/05/31/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<blockquote>
<p>好久没更新过博客了，之前一段时间及比较忙，快要期末了，考试要准备，课程设计要做，中间还水了个自动打卡的脚本，闲下来的时间比较少（可能是打游戏去了），就一直没更新吧，上一次更新是两三周之前，虽然不存在什么有人催更的问题（滑稽），但是自己心里还是不舒服，于是就来水一篇博客。</p>
</blockquote>
<h1 id="1、-基本功能"><a href="#1、-基本功能" class="headerlink" title="1、 基本功能"></a>1、 基本功能</h1><ol>
<li>抢答器系统提供八路抢答，分别代表八支队伍，分别用按钮S1-S8表示，最先按下按钮的队伍对应的LED灯会亮起来，其他队再按下按钮无效。</li>
<li>当按下开始抢答按钮（reset）之后计时模块开始计时30S，扬声器会发出短暂报警，LED灯亮，若30秒之内有队伍按下抢答按钮，则计时模块停止计时，同时扬声器短暂报警；若30S内没有队伍按下抢答按钮，到了30S时计时停止，扬声器短暂报警，且LED灯熄灭。</li>
<li>抢答器系统设有清除按钮/开始按钮（reset），第一次按下之后，代表抢答的LED灯亮，计时器开始计时，再次按下，所有的LED灯熄灭，计时器归零，系统回到初始状态。</li>
</ol>
<a id="more"></a>

<h1 id="2、方案设计"><a href="#2、方案设计" class="headerlink" title="2、方案设计"></a>2、方案设计</h1><p>电路分为两个主要的模块——抢答模块和计时模块，报警电路穿插在这两个模块之间，配合两个电路的特点，能够达到报警的效果。</p>
<p>具体结构框图如图1所示：</p>
<img src="https://blog.steventan.top/images/八路抢答器课设报告/image-20200531153300891.png" alt="图1" style="zoom:80%;" />



<h1 id="3、单元电路设计"><a href="#3、单元电路设计" class="headerlink" title="3、单元电路设计"></a>3、单元电路设计</h1><h2 id="3-1抢答模块的设计"><a href="#3-1抢答模块的设计" class="headerlink" title="3.1抢答模块的设计"></a>3.1抢答模块的设计</h2><p>电路仿真图如图2所示。该部分电路主要由74LS175和74LS20芯片构成。该电路主要功能是分辨出最先按下按钮的队伍，并将其锁定，其他队伍再按下按钮无效，同时对应队伍的LED灯亮起。</p>
<p>该电路主要原理是将D触发器输出的结果  经过两个四与非门，反馈给队伍抢答按钮的输入电平。当抢答还没开始的时候，D触发器输出Q都是低电平，  都为高电平，经过与非门之后就是输出为低电平，再将两个与非门或非，结果就为高电平，此时任何一个队伍按下按钮都是有效的。</p>
<p>当有一个队伍已经抢答成功，那么八个D触发器的输出经过两个四输入与非门之后，有一个与非的结果为高电平，再将两者或非，结果就为低电平，此时再有队伍按下抢答按钮就无效，LED灯的亮灭不会发生改变。</p>
<p>D触发器的时钟输入是由八个按钮的电平相或得到，只要有一个队伍在抢答有效的时间内按下按钮，并且在此之前没有其他队伍按下抢答按钮，就会产生一个上升沿；若已有队伍抢答成功，再有队伍按下按钮，电平不会发生变化，时钟不会检测到上升沿。</p>
<p>清零效果的实现主要是利用D触发器的 ~CLR端，清零按钮默认是高电平状态，当按下之后会出现一个低电平的信号，输送给 ~CLR端，达到清零效果。</p>
 <img src="https://blog.steventan.top/images/八路抢答器课设报告/image-20200531153428970.png" alt="图2" style="zoom:80%;" />



<p>​    抢答部分的报警电路是有一个蜂鸣器构成，高电平引脚接的是74LS175的时钟端口，第一个队伍按下按钮之后时钟端会产生一个高电平信号，蜂鸣器得到这个高电平信号之后会，发出短暂的响声，提示已有队伍抢答成功。</p>
<h2 id="3-2计时模块的设计"><a href="#3-2计时模块的设计" class="headerlink" title="3.2计时模块的设计"></a>3.2计时模块的设计</h2><p>电路仿真图如图3所示。计时模块主要有74LS73、74161和74LS00芯片构成。计时模块的个位数字0-9是74161芯片来控制的，使用反馈清零法，使其在0-9之间循环；十位的数字0-3是由74LS73芯片来控制的，它的时钟信号是74161的置数信号，每当74161需要置数，74LS73就会收到一个时钟脉冲，十位的计数就加一，74161的置数的信号也相当于进位信号。</p>
<p>计时模块的“开关”主要是用74LS73芯片中的JK触发器构成的一个T触发器来实现的，JK触发器的时钟信号是由前面的清零按钮控制，按下清零按钮之后会产生一个下降沿，触发器的输出发生翻转，也就模拟了开关状态的改变。当计时器十位数字为3时，也就是30秒的计时时间到了，74LS73这时Q1和Q2都为高电平，将其接到74LS00的与非门上面，与非的结果为0。再将这个与非的结果和上面JK触发器输出的电平相与得到计时模块的总开关，只要这两者有一个为低电平，总开关就是断开的，计时模块停止工作。比如：当计时器到了30秒的时候74LS73输出Q1和Q2与非的结果为0，此时，计时模块停止工作，数码管显示停留在30秒的时候。计时模块有一个LED指示灯，当“开关”接通时，指示灯亮，当计时到达30秒或者还未开始抢答时，指示灯熄灭。</p>
<p>​    计时的时钟脉冲是由前面抢答模块的D触发器输出四个四个相与非，再将两个与非的结果或非和74LS73的Q1、Q2或非的结果以及一个1HZ的方波信号三个信号相与的结果，只要有一个条件不满足，计数器就会停止计数。比如：已有人抢答成功，那么第一个条件不满足，计时器停止计数；计时器计时到了30秒，那么第二个条件不满足，计数器停止计数。</p>
<p>​    计时模块的报警电路有两部分，一个是计时时间到了30秒，蜂鸣器报警，另一个是抢答开始，蜂鸣器发出报警。第一部分蜂鸣器的高电平端口接到计时模块的电源上，低电平端口接到74LS73输出结果相与非后的端口，计时到了30秒时，74LS73输出结果相与非后的结果为0，高低电平端口有电位差，蜂鸣器发出报警声，同时计时模块的“开关”会断开，所以蜂鸣器的高电平端口也会变为低电平，所以蜂鸣器只会短暂报警。第二部分蜂鸣器的高电平端口接到计时模块的JK触发器的输出端，低电平端口接清零按钮的输出。初始状况蜂鸣器高低电平的电位差为-5V，在按下开始抢答按钮的一瞬间，点位差变成5V蜂鸣器会发出短暂报警声。</p>
 <img src="https://blog.steventan.top/images/八路抢答器课设报告/image-20200531153526098.png" alt="图3" style="zoom:80%;" />

<h1 id="4、主要元器件的选择"><a href="#4、主要元器件的选择" class="headerlink" title="4、主要元器件的选择"></a>4、主要元器件的选择</h1><p>此八路抢答系统主要由两块74LS175、两块74LS73一块74LS20、一块74LS00、一块74161芯片以及若干非门和与门组成。</p>
<p>所有元器件列表：</p>
<table>
<thead>
<tr>
<th>器件名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>74LS175（D触发器）</td>
<td>2片</td>
</tr>
<tr>
<td>74LS73（JK触发器）</td>
<td>2片</td>
</tr>
<tr>
<td>74LS20（四输入与非门）</td>
<td>1片</td>
</tr>
<tr>
<td>74LS00（二输入与非门）</td>
<td>1片</td>
</tr>
<tr>
<td>74161（十六进制计数器）</td>
<td>1片</td>
</tr>
<tr>
<td>LED</td>
<td>9个</td>
</tr>
<tr>
<td>电阻（470Ω）</td>
<td>9个</td>
</tr>
<tr>
<td>两输入或门</td>
<td>8个</td>
</tr>
<tr>
<td>两输入或非门</td>
<td>1个</td>
</tr>
<tr>
<td>三输入与门</td>
<td>1个</td>
</tr>
<tr>
<td>两输入与门</td>
<td>1个</td>
</tr>
<tr>
<td>PB_DPST按钮</td>
<td>9个</td>
</tr>
<tr>
<td>蜂鸣器</td>
<td>3个</td>
</tr>
<tr>
<td>数码管</td>
<td>2个</td>
</tr>
</tbody></table>
<p>74LS175引脚和逻辑功能表：</p>
<p>   <img src="https://blog.steventan.top/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153551489.png" alt="image-20200531153551489"></p>
<p><img src="https://blog.steventan.top/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153558547.png" alt="image-20200531153558547"></p>
<p>74LS73引脚和逻辑图：</p>
<p>   <img src="https://blog.steventan.top/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153605422.png" alt="image-20200531153605422"></p>
<p><img src="https://blog.steventan.top/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153611215.png" alt="image-20200531153611215"></p>
<p>74161引脚和逻辑图：</p>
<p>   <img src="https://blog.steventan.top/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153618898.png" alt="image-20200531153618898"></p>
<p><img src="https://blog.steventan.top/images/%E5%85%AB%E8%B7%AF%E6%8A%A2%E7%AD%94%E5%99%A8%E8%AF%BE%E8%AE%BE%E6%8A%A5%E5%91%8A/image-20200531153622958.png" alt="image-20200531153622958"></p>
<h1 id="5、调试结果及分析"><a href="#5、调试结果及分析" class="headerlink" title="5、调试结果及分析"></a>5、调试结果及分析</h1><h2 id="5-1调试中存在的问题"><a href="#5-1调试中存在的问题" class="headerlink" title="5.1调试中存在的问题"></a>5.1调试中存在的问题</h2><p>1.多个队伍同时按下抢答按钮会显示都抢答成功</p>
<p>造成这一结果的原因，一方面可能是仿真电路的时间步长和实际的时间步长不一致，仿真需要实时的计，算运行的比实际电路要慢很多，就造成了第一个按下的信号还没反馈回去，第二个按下按钮队伍的信号也一起发出来了，最后就出现多个队伍对应的LED亮起；另一方面可能是反馈回给按钮的信号延迟太高，比第一个按下按钮的队伍和第二个按下按钮的队伍的时间差还要长，也是导致第一次按下按钮信号没反馈回去，第二次的信号就发出去了。这种情况就是电路设计的问题了，但是受条件限制，无法搭建实际的电路，只能用仿真调试，具体的原因也无法进一步探究。</p>
<p>2.蜂鸣器不响（只能响一个）</p>
<p>  在Multisim仿真里面，用示波器测了蜂鸣器两个端口的电位波形，蜂鸣器两个端口有正向的电位差但是蜂鸣器不会响。经过多次的调试发现需要把蜂鸣器单独拿出来并给它一个正向的电位差，再将其接到实际电路中，这样蜂鸣器就可以响了，但是三个蜂鸣器都经过这样的操作之后，只有最后一个能响。造成这种现象的原因应该是Multisim仿真软件的问题，示波器测得的信号没有问题，不能搭建实际的电路也无法进一步验证。</p>
<h1 id="6、心得体会"><a href="#6、心得体会" class="headerlink" title="6、心得体会"></a>6、心得体会</h1><p>​    经过这次八路抢答器的课程设计，我收获颇多。一是加深了计数器、触发器、编码器、译码器的理解，熟悉的掌握了计数器、D触发器和JK触发器的使用，能将用所学的理论知识实际运用起来。二是明白了，自己想象的、构思的和实际做起来是有一定的差异的，刚开始选这个题目的时候就觉得这个题不难，第一天构思的时候也觉得还好，但是在Multisim搭建电路的时候出现了很多意料之外的问题，有的可能是软件的问题，有的就确实是自己搭建的电路有问题，用到的芯片多了结构复杂起来了，一个地方不小心接错了一根线就会导致整个电路出现问题。还有一点体会就是自己之前画的仿真电路，过一段时间可能就不记得为什么要那么画了，然后又要自己重新推导一遍。</p>
<p>​    在这次的课程设计中也发现了自己的许多问题，许多还要提高的部分。第一个是对很多元器件、芯片不熟悉，每次使用都要找逻辑功能表，很不方便。另一点是自己设计逻辑电路图的布局和走线还有待加强，这次课程设计的题目涉及到的模块和功能相对较多，各种元器件的布局以及走线就显得很重要了。</p>
<p>​    总之，经过这次的课程设计，发现了自己存在的许多问题，也有很多的收获，希望在之后的学习中可以进一步提高。</p>
]]></content>
      <categories>
        <category>数字与逻辑电路</category>
      </categories>
      <tags>
        <tag>数字与逻辑电路</tag>
      </tags>
  </entry>
  <entry>
    <title>入坑hexo</title>
    <url>/2020/02/26/%E5%85%A5%E5%9D%91hexo/</url>
    <content><![CDATA[<p>&emsp; &emsp;经过两天的努力，终于把hexo配置好了，虽然有些地方还是不太满意，但也就只能到这里了，干不下去了，就这样用着吧。</p>
<p>&emsp;&emsp;现在是把它放在白嫖来的阿里云的服务器上，本来是放到GitHub上的，结果发现GitHub的加载速度实在是太“感人了”，我就放弃了。这个服务器今年八月份就过期了，之后不知道这个博客会何去何从，可能会自己再买一个，可能就不会再挂到服务器上了。</p>
<a id="more"></a>

<p>&emsp;&emsp;搞这个也算是完成了自己的一个夙愿吧，本来上学期在学校就想建一个博客，奈何在学校时间有限，当时是临近期末，还要备考，看了一下大概就放弃了（当时看见还要装一大堆东西就不想搞，不知道看的谁的教程，居然还要装ruby🌚）。趁着现在这个特殊时期，待在家没太多事，就折腾了两天，弄了一下。</p>
<p>&emsp;&emsp;现在对Markdown的语法还不是很熟，写起来不是很顺手，就上个学期搞课设的时候写了一点，排版还很丑（手动滑稽），明天抽空看一下练习一下吧，补几篇笔记。</p>
<p>&emsp;&emsp;就到这里吧。。。。。。</p>
<p>&emsp;&emsp;希望可以坚持写下去，不要白费两天的功夫。</p>
]]></content>
      <categories>
        <category>感悟</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu服务器上安装MySQL8</title>
    <url>/2020/03/01/%E5%9C%A8Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85mysql8/</url>
    <content><![CDATA[<p>在<a href="http://dev.mysql.com/downloads/repo/apt/，下载一个mysql-apt-config_0……._all.deb，传到服务器上，用dpkg" target="_blank" rel="noopener">http://dev.mysql.com/downloads/repo/apt/，下载一个mysql-apt-config_0……._all.deb，传到服务器上，用dpkg</a> -i mysql-apt-config_0._…..all.deb安装执行，选择mysql8，OK之后回到终端窗口</p>
<p>执行sudo apt update</p>
<p>然后使用sudo apt install mysql-server命令，就会安装MySQL8.0</p>
]]></content>
      <categories>
        <category>软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用好学生优惠</title>
    <url>/2020/02/27/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A5%BD%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0/</url>
    <content><![CDATA[<p><img src="https://blog.steventan.top/images/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A5%BD%E5%AD%A6%E7%94%9F%E4%BC%98%E6%83%A0/loq428.png" alt=" loq428.png"></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本文介绍的是利用学生身份可以享受到的相关学生优惠权益，但也希望各位享受权利的同时不要忘记自己的义务，不要售卖、转手自己的学生优惠资格，使得其他同学无法受益。</p>
<p><strong>欢迎提交 issue 给我们你发现的实用资源！</strong> | 本文更新于 2019 年 05 月 12 日</p>
<p>点击 <code>watch</code> 可以得到更新信息哟！</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li>查看、利用、转载、引用本集锦请查看 <a href="https://github.com/ivmm/Student-resources/blob/master/lisence" target="_blank" rel="noopener">License</a>。</li>
<li>一切官方的助学资金等，请咨询学校领导、辅导员、班主任，请勿向陌生账户转账！</li>
<li>校园借贷风险极高，请谨慎尝试。</li>
<li>对需要出示身份证、手持身份证的资源请保持谨慎。</li>
<li>保管好自己的学生证、身份证，不要随意丢弃。</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>高考已经过去，你们也将迎来不同于以往的大学生活，大学或许对之前的12年管制式生活来说是解放了，不过你也知道的，解放后面是什么，脱离了父母和老师的管束以及适当的财务自主，你的生活并不会就无比精彩。</p>
<p>让自己的大学生活过得积极而精彩：</p>
<ol>
<li>多参加校级、省级、国家级的比赛，你的比较对象就不会是同班同学了而是同龄人，视野更大。</li>
<li>多上台讲讲，第一次第二次第三次可能会小心脏砰砰跳，后面真的就见怪不怪了，会自信很多。</li>
<li>不要再默默无闻了，让老师们注意到你，都大学了上课还不敢举个手？</li>
<li>做点义工，为社会做点贡献，工作了就真没时间了。</li>
<li>做人做事记得留个证据，留个发票，留个单子。</li>
<li>多向长辈们问候问候，偶尔放个长假了就去看看。</li>
</ol>
<p>那么就期待着9月开启你的上当受骗之旅吧，不过可能在6月买电脑买手机的时候就已经上当受骗。（逃～）</p>
<h1 id="学生包"><a href="#学生包" class="headerlink" title="学生包"></a>学生包</h1><p>各类学生优惠项目经过许多年的发展，很多学生包已经不单单只通过 edu 邮箱验证身份了，而且使用 @edu.cn 反而会降低申请成功率。 建议使用学生证、入学通知书等有学院官方标志和日期的工具来证明自己的身份。</p>
<ul>
<li><strong><a href="https://education.github.com/pack" target="_blank" rel="noopener">Github 学生包</a></strong>，高质量的开发工具集合，并提供 DIgitalocean 的 50美元代金券，免费域名一枚。</li>
<li><strong><a href="https://imagine.microsoft.com/zh-cn/catalog" target="_blank" rel="noopener">Microsoft Imagine 学生包</a></strong>，免费使用微软的开发软件，包括 Windows Server 系统，以及 Azure 学生订阅。</li>
<li><strong><a href="https://aws.amazon.com/cn/education/awseducate/" target="_blank" rel="noopener">AWS 学生包</a></strong>，亚马逊云计算的学生包，可以获得至少 $40 的优惠和教育培训。</li>
<li><strong><a href="http://www.autodesk.com.cn/education/home" target="_blank" rel="noopener">Autodesk 学生包</a></strong>，旗下 AutoCAD , 3DMAX , Maya 等软件，其（教育版）免费试用期可延长至三年。</li>
<li><strong><a href="https://www.jetbrains.com/student/" target="_blank" rel="noopener">JetBrains 学生包</a></strong>，免费使用各类开发工具和集成工具。</li>
<li><strong><a href="https://edu.google.com/products/productivity-tools/" target="_blank" rel="noopener">G Suite for Education</a></strong>，为教育用户提供的谷歌生产力工具套件（大陆不在申请区之内）。</li>
<li><strong><a href="http://www.lindo.com/index.php?option=com_content&view=article&id=120&Itemid=45" target="_blank" rel="noopener">LINGO Educational Research License</a></strong>, LINGO 教育授权，著名线性与非线性求解器，求解优化模型的最佳选择，数学建模必备。</li>
</ul>
<h1 id="学生优惠"><a href="#学生优惠" class="headerlink" title="学生优惠"></a>学生优惠</h1><ul>
<li><strong><a href="https://products.office.com/en-us/student?tab=students" target="_blank" rel="noopener">Office in Education</a></strong>，微软家提供的免费 Office 365 教育优惠，中国大多数学校无缘申请。</li>
<li><strong><a href="https://promotion.aliyun.com/ntms/act/campus2018.html?accounttraceid=22aca9b8-8f26-44f2-b514-d97cf21a6654&userCode=oitiwrd3" target="_blank" rel="noopener">阿里云+云翼计划</a></strong>，118元/年，阿里云ECS+OSS+域名+机器学习API+Clouder认证。  24岁以下实名认证即可获得，无需验证学生身份!!</li>
<li><strong><a href="https://www.qcloud.com/act/campus" target="_blank" rel="noopener">腾讯云+校园计划</a></strong>，10元一个月的云服务器租用，免费域名、云储存，需要抢购。</li>
<li><strong><a href="https://developer.huaweicloud.com/campus" target="_blank" rel="noopener">华为云+云创校园计划</a></strong>，9元/月 24岁及以下免学生认证，实名认证即可购买，需要抢购。</li>
<li><strong><a href="https://cloud.baidu.com/campaign/campus-2018/index.html" target="_blank" rel="noopener">百度云启航校园计划</a></strong>，云服务器半年124元</li>
<li><strong><a href="http://www.apple.com/cn-k12/shop" target="_blank" rel="noopener">苹果教育商店</a></strong>，苹果设备优惠，Music和 Pro APP 优惠，暑假还会有学生优惠大促销。</li>
<li><strong><a href="https://www.microsoftstore.com.cn/student?Icid=StoreNavi_EDU" target="_blank" rel="noopener">微软教育商店</a></strong>，9折购买微软旗下的各种硬件设备。</li>
<li><strong><a href="http://www.onthehub.com/" target="_blank" rel="noopener">OnTheHub 教育商店</a></strong>，PD 和 VMware 的虚拟机优惠，以及更多软件优惠。</li>
<li><strong><a href="https://www.siteground.com/student-hosting.htm" target="_blank" rel="noopener">SiteGroud 学生计划</a></strong>，WP 官方推荐的主机托管商提供 $1.99/月 高性能 CP 托管。</li>
<li><strong><a href="https://www.spotify.com/hk-zh/student/" target="_blank" rel="noopener">Spotify 学生优惠</a></strong>，Spotify Premium学生订阅半价优惠。</li>
<li><strong><a href="https://pantheon.io/edu" target="_blank" rel="noopener">Pantheon 学生版</a></strong>，专业高性能网站托管的学生优惠。</li>
<li><strong><a href="http://coupon.dji.com/cn/edu" target="_blank" rel="noopener">大疆教育优惠</a></strong>，大疆产品的教育折扣。</li>
<li><strong><a href="https://todoist.com/education" target="_blank" rel="noopener">Todoist教育优惠</a></strong>，强大的任务、思路整理工具提供半价教育优惠。</li>
<li><strong><a href="https://setapp.com/educational-discount" target="_blank" rel="noopener">SetAPP教育优惠</a></strong>，macOS 应用合集订阅包半价优惠，非常适合MAC学生党，每月4.99刀</li>
<li><strong><a href="http://app.eagle.cool/forum/topic/5354/%E6%88%91%E6%98%AF%E5%AD%A6%E7%94%9F%E6%88%96%E6%95%99%E5%B8%88-%E6%98%AF%E5%90%A6%E4%BA%AB%E6%9C%89%E4%BC%98%E6%83%A0%E4%BB%B7%E6%A0%BC" target="_blank" rel="noopener">Eagle教育优惠</a></strong>, Win/Mac系统，设计师图片管理工具，支持试用一个月，原价199，优惠价139，需提供身份和证件信息。优秀的本地图片管理工具，搭配学生版OneDrive进行同步管理，美滋滋。（目前已支持图片、视频、字体等类型文件的管理）</li>
</ul>
<h1 id="实用干货"><a href="#实用干货" class="headerlink" title="实用干货"></a>实用干货</h1><ul>
<li><strong><a href="https://creativemarket.com/free-goods" target="_blank" rel="noopener">CreativeMarket Free Goods</a></strong>，每周免费六款设计资源，电商、前端必备。</li>
<li><strong><a href="https://www.axure.com/edu" target="_blank" rel="noopener">Axure</a></strong>， 原型设计工具，产品、运营必备，学生、教师免费。</li>
<li><strong><a href="https://www.adobe.com/cn/products/xd.html" target="_blank" rel="noopener">Adobe XD</a></strong>，原型设计工具，<del>没想到吧我Adobe也有免费的东西啦XD</del> 官网直接提供免费版，奋起直追Mac的Sketch，Win党难得的福利。此外Adobe还提供对XD插件设计的奖励，<a href="https://www.adobe.io/apis/creativecloud/xd.html" target="_blank" rel="noopener">可参与设计开发可供XD使用的插件</a>。</li>
<li><strong><a href="http://education.minecraft.net/get-started" target="_blank" rel="noopener">Minecraft</a></strong>， 我的世界教育免费版 ，仅支持邮箱。</li>
<li><strong><a href="http://www.wolfram.com/mathematica/pricing/students-individuals.php" target="_blank" rel="noopener">Mathematica</a></strong>， 现代科学计算软件，3折优惠 50刀，添加购物车后显示。</li>
<li><strong><a href="https://www.tableau.com/zh-cn/academic" target="_blank" rel="noopener">Tableau</a></strong>， 数据可视化分析软件，对学生、教室以及教育组织提供免费使用。</li>
</ul>
<h1 id="推荐软件"><a href="#推荐软件" class="headerlink" title="推荐软件"></a>推荐软件</h1><ul>
<li><strong><a href="https://cloudconvert.com/" target="_blank" rel="noopener">CloudConvert</a></strong>，转码神器，格式齐全的在线转码利器。</li>
<li><strong><a href="https://smallpdf.com/" target="_blank" rel="noopener">Smallpdf</a></strong>，专业文档转PDF，PDF转文档神器。</li>
<li><strong><a href="https://github.com/drew-royster/canvasFileSync" target="_blank" rel="noopener">Canvas File Sync</a></strong>，Syncs Canvas-LMS课程文件</li>
</ul>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><strong>少数派：</strong><a href="https://sspai.com/post/39430" target="_blank" rel="noopener">在校师生福利：Apple、微软、Adobe 等产品如何通过教育优惠购买</a></li>
<li><strong>少数派：</strong><a href="https://sspai.com/post/43533" target="_blank" rel="noopener">学生专属福利，你可能还不知道这些常用服务其实可以更便宜</a></li>
</ul>
<h1 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h1><p><strong>买电脑：</strong> 学生购买电脑多为笔记本，可关注 <a href="http://tieba.baidu.com/f?kw=%E7%AC%94%E8%AE%B0%E6%9C%AC&ie=utf-8" target="_blank" rel="noopener">笔记本吧</a><br>如果为台式可关注 显卡吧/图拉丁吧/电脑吧 等专业硬件社区，或直接关注微信公众号“笔吧评测室”，由笔记本吧吧主和吧务团队运营，质量保证。</p>
<p><strong>如何科学提问：</strong> 《<a href="http://git.oschina.net/mifar/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">提问的智慧</a>》 《<a href="https://github.com/octowhale/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md" target="_blank" rel="noopener">别像弱智一样提问</a>》</p>
<p><strong>搜索引擎：</strong> 为了你的身体健康、事业有成，请尽量<strong>减少使用百度</strong>的频率。</p>
<p><strong>PPT 制作：</strong>《<a href="https://www.mf8.biz/ppt-tips/" target="_blank" rel="noopener">放 PPT 之前，请你注意这一些！</a>》</p>
<p>原作者博客：<a href="https://www.mf8.biz/" target="_blank" rel="noopener">https://www.mf8.biz/</a></p>
]]></content>
      <categories>
        <category>羊毛</category>
      </categories>
      <tags>
        <tag>羊毛</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>令人心动的offer观后感</title>
    <url>/2020/03/12/%E4%BB%A4%E4%BA%BA%E5%BF%83%E5%8A%A8%E7%9A%84offer%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>&emsp;&emsp;经过差不多一星期，把令人心动的offer给看完了，其实很舍不得的，不管是电视剧还是综艺或者是小说，只要有情节的，每次看完我都挺舍不得的，因为之后就看不到那些人了。在看的那段时间，或许自己心里就把他们给当成朋友了，看完一部之后就像和好友惜别，所以总是心里会有点难过。</p>
<p>&emsp;&emsp;就不多扯了，说说自己这些天看的感受吧！</p>
<a id="more"></a>

<p>&emsp;&emsp;这八位实习生真的都十分优秀，除了李晨还要加把油，其实李晨这一个月的实习成长也是非常之快的，从第一期开始几乎算是没入律师的门，说话也结结巴巴、比较拖沓，到第二期第三期一点一点的进步，到最后一期说话都流畅很多了，可以及时get导对手的点并给予反击，成长是很大的。而且，李晨除了能力，他也有很多其他的优点，比如可爱的表情，有一期就是因为他的可爱让邓冰莹选择他为队友，在职场中让别人和自己相处的很舒适也别人选择你作为队友、同事的一个优点。然后李浩源真的是才华横溢，总是出口成章，每句从他嘴里出来的话都是金句，逻辑思维也是十分的强，还参加过诗词大会，和我这种俗人真的是比不了，写个感受都写成这样（手动滑稽）。摘记一下他在节目中说过的金句，第一次面试的时候说的：<strong>作为一只“菜鸟”，希望能得到一次宝贵的机会。我期望这里能是“菜鸟”翱翔的起点，我亦深知，若是鲲鹏，而非北海不就的道理。</strong>在最后的面试的时候说的：<strong>我有足够的积累，但是又一直在路上，所以有无限的可能。</strong>这两句真的都是非常非常的喜欢。优秀的人总是这么优秀，太喜欢浩源的才华了。何运晨也是相当的优秀，他和浩源一起配合简直是完美，两个人十分的契合，互相都能get到对方的点，知音相遇啊，好运来组合这得是完美。其他人就不一个一个说了。（感觉我在记流水账，毫无才华可言，和这些优秀的人比起来简直是无地自容）</p>
<p>&emsp;&emsp;这部综艺真正吸引我的地方，是让我了解到从象牙塔初入社会实习的这样的一个状况是怎样的，这也是我一直都想知道的，在这部综艺中一点一滴的体现着。我是从知乎上面看到的一点小片段，当时那个片段我觉得很励志，就把名字记了下来，本来都忘这回事了，一个无聊的下午想起来了，就搜了一下，然后就一发不可收拾，一集一集的看完了，每天都看，一天不看就觉得心里空落落的，每集也都很有趣，也很励志，最后也被这些人给成功圈粉了，人格魅力啊，这真的太强了。</p>
<p>&emsp;&emsp;看完之后也自己反省了一下，第一个，自己是不是应该多看些书，多积累些知识，什么是腹有诗书气自华，李浩源就是最好的解释了，整个人的气场都是完全不一样，我觉得这是我应该要学习的地方，还要多读书，现在应该要从读小说，到读那些无聊的书了，那些书才能真正的提升人的一个认知，就比如：乌合之众，买了放那好久没看，几次拿起来看看不下去，又给放回书架上面，这个学期静下心来把这本书给啃完，在好多地方都看到推荐这本书了。第二个是口头的表达能力，我觉得自己就是李晨吧，可能李晨都不如，表达能力太差了，有的时候说一件事都说不清楚，这也是自己需要提升的地方。第三个是人际交往的能力，这一方面现在来说我觉得自己还是可以的，比之前有很大的进步了，但还是可以继续提升。其实，我觉得人际交往和自己的自信有关，自信又和第一点提到的，自己的知识储备有关，也和第二点提到的口头表达能里有关，也是人际交往的一个基本能力吧。</p>
]]></content>
      <categories>
        <category>感悟</category>
        <category>影视</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--操作系统的形成与发展</title>
    <url>/2020/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BD%A2%E6%88%90%E4%B8%8E%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h2 id="操作系统的形成时期"><a href="#操作系统的形成时期" class="headerlink" title="操作系统的形成时期"></a>操作系统的形成时期</h2><h3 id="手动操作时期"><a href="#手动操作时期" class="headerlink" title="手动操作时期"></a>手动操作时期</h3><img src="https://blog.steventan.top/images/操作系统的形成与发展/vuMCXHTLqJBOh5t.png" alt="image.png" style="zoom:80%;" />

<h4 id="存在缺点"><a href="#存在缺点" class="headerlink" title="存在缺点"></a>存在缺点</h4><ol>
<li><p>用户独占全部计算机资源</p>
</li>
<li><p>CPU等待人工操作</p>
</li>
<li><p>CPU与I/O设备串行操作</p>
</li>
</ol>
<h3 id="监控程序阶段（早起批处理阶段）"><a href="#监控程序阶段（早起批处理阶段）" class="headerlink" title="监控程序阶段（早起批处理阶段）"></a>监控程序阶段（早起批处理阶段）</h3><img src="https://blog.steventan.top/images/操作系统的形成与发展/4QMJfoxRIXGiu9C.png" alt="单道批处理系统流程图" style="zoom:67%;" />

<p>单道批处理系统流程图  </p>
<a id="more"></a>

<h2 id="操作系统的成熟阶段"><a href="#操作系统的成熟阶段" class="headerlink" title="操作系统的成熟阶段"></a>操作系统的成熟阶段</h2><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ol>
<li>程序浮动与存储保护问题</li>
<li>CPU的调度和管理问题</li>
<li>其他资源的管理和调度问题</li>
</ol>
<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol>
<li>人机交互</li>
<li>共享主机</li>
<li>便于用户上机</li>
</ol>
<img src="https://blog.steventan.top/images/操作系统的形成与发展/vrjo1l8dPaFKY7c.png" alt="image.png" style="zoom:67%;" />

<h2 id="进一步发展时期"><a href="#进一步发展时期" class="headerlink" title="进一步发展时期"></a>进一步发展时期</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>用ssh公钥配对登录服务器</title>
    <url>/2020/03/01/%E7%94%A8ssh%E5%85%AC%E9%92%A5%E9%85%8D%E5%AF%B9%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="1-生成公钥"><a href="#1-生成公钥" class="headerlink" title="1.生成公钥"></a>1.生成公钥</h3><p>ssh-keygen -t rsa -b 4096 -C “你的邮箱地址”</p>
<p><em>-t 指定加密算法； -b 指定生成的密钥长度； -C 一句话，一般都填邮箱地址。</em></p>
<p><em>更多参数说明可以在终端输入：ssh-keygen –help 查看</em></p>
<h3 id="2-将公钥写入远程主机"><a href="#2-将公钥写入远程主机" class="headerlink" title="2.将公钥写入远程主机"></a>2.将公钥写入远程主机</h3><p>在自己电脑上打开用户目录下的/.ssh/id_rsa.pub公钥文件，将其中的内容粘贴到服务器的、root/.ssh/authorized_keys目录的文件里面</p>
<h3 id="3-修改ssh配置文件，禁止密码登录，允许秘钥登录"><a href="#3-修改ssh配置文件，禁止密码登录，允许秘钥登录" class="headerlink" title="3.修改ssh配置文件，禁止密码登录，允许秘钥登录"></a>3.修改ssh配置文件，禁止密码登录，允许秘钥登录</h3><p>vim /etc/ssh/sshd_config </p>
<p>将里面的内容修改如下所示：</p>
<p># PubkeyAuthentication yes   中将#删除，允许秘钥登录</p>
<p>PasswordAuthentication yes  中yes修改为no，禁止密码登录</p>
<p><em>禁止密码登录可以防止暴力破解，虽然也没人来攻击</em></p>
<h3 id="4-重启ssh服务"><a href="#4-重启ssh服务" class="headerlink" title="4.重启ssh服务"></a>4.重启ssh服务</h3><p>service ssh restart</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>《摔跤吧！爸爸》观后感</title>
    <url>/2020/06/25/%E3%80%8A%E6%91%94%E8%B7%A4%E5%90%A7%EF%BC%81%E7%88%B8%E7%88%B8%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>好久没看过电影了，从开学之后好像就没看了，一方面是开学确实时间紧一点，主要还是我自己没去找电影看吧。OK，下面进入正题。</p>
<p>电影主要讲的是两个女儿帮爸爸实现了摔跤世界冠军的梦想。年轻的时候，电影的主人公爸爸（名字忘了叫啥了）年轻的时候是一个摔跤全国冠军，但是因为国家贫穷落后，再加上官员的贪污腐败、不重视体育，导致运动员得不到好的训练，这真是“食马者，不知其能千里而食也！”。所以这个爸爸一直很好遗憾，后来他就想要生个儿子，来替自己实现摔跤世界冠军的梦想，但是造化弄人啊，生了三个全是女儿。</p>
<p>故事的转机发生在他的有一次这两个女儿因为两个男孩骂了她们俩，就把那两个男孩打得鼻青脸肿，这个时候他就突然意识到，为什么女孩就不能摔跤，来帮自己实现梦想呢？于是乎，他就不顾全村人异样的眼光，开始对这两个女儿开始进行摔跤训练，女儿们也反抗过，开始是找借口说训练太累了坚持不了了，后来调慢他们爸爸的闹钟，故意把灯泡烧坏，各种小伎俩都使了出来，还是没有用。但是在他们朋友的一个婚礼上，故事又出现了转机。</p>
<p>她们逃掉了一次训练，去参加一个好朋友的婚礼，被她们的父亲发现了，她们的父亲当着所有人的面，将“我”扇了一巴掌（故事前面一段是以主人公爸爸的侄子的回忆展开的，这里就用第一人称了），后来她们两个人和这个朋友聊天的时候，朋友点醒了他们，她们的爸爸这样对她们，至少还在乎他们，而不是像其他的父亲一样，只盼着女儿快点长到14岁，把女儿嫁出去，帮别人做洗衣做饭生孩子，像摆脱了一个累赘似的，而他们这样至少可以不要像大多数女人一样，可以实现真正意义上的自由。</p>
<p>从这之后，她们俩就开始认真训练，大女儿geeta第一次去村里参加比赛，和男孩摔跤比赛，她在四个男孩中选了看起来最强壮的那个。观众都在猜geeta能坚持几秒，但是开局出乎观众们所料，两个旗鼓相当，geeta完全不落下风，但是最后还是败下阵来，不过父亲并不失望。回去之后，geeta不甘心，问爸爸下次比赛是什么时候，之后geeta越发抓紧训练，在后面的比赛中一路披荆斩棘，战胜了邦里的所有男孩，后来参加国家比赛，尽管体重不达标，但是任然蝉联了三年的全国女子摔跤冠军。</p>
<p>孩子长大了总是要出去的，geeta要去印度国家体育中心去接收新的训练。在那呆了一段时间，第一次回家的时候，geeta似乎不再是那个geeta了，头发留长了，心思也不全部在摔跤上面。更要命的是她觉得她在国家体育中心接受的训练技巧比之前父亲的的技巧要好。父亲也不服气，于是他们俩就比了一场，开始是不相上下的，但是随着时间越来越长，上了年纪的父亲体力跟不上，最后被干翻在泥地里。就这样geeta和父亲之间就产生了隔阂。</p>
<p>之后geeta参加的各种国际赛事都是非常的不顺利，再后来geeta的妹妹也拿下了全国总冠军，进入到国家体育中心训练。再和geeta的相处过程中，她潜移默化的改变了geeta，老家那边，妈妈也在不断的劝爸爸好好地和geeta谈谈。在一次国际赛事之前，终于等到了这个契机，教练要geeta从55公斤级降级到51公斤级的比赛，geeta就给父亲打了电话，把情况告诉了父亲，这个片段也是很感人的一个片段，父亲就决定亲自去到帕提亚拉给geeta训练，指导geeta比赛。geeta确实找回了以前的状态，但是新的矛盾又出现了。</p>
<p>在比赛中前夕，测体重的时候教练发现geeta的体重没有减下来，提名要将geeta取消比赛资格。经过geeta的父亲向印度体育委员会求情，体育委员会同意再给geeta一次机会。</p>
<p>比赛正式开始之后，geeta经过父亲的指导，一次次的顺利晋级，最后拿下了全英赛的摔跤世界冠军。</p>
<p>这部电影挺感人的，泪点低的我，流下了感动的泪水。第一次是geeta和父亲和好的时候，第二次是geeta顺利晋级决赛，最后是geeta拿下冠军。</p>
<p>看完之后也有几个想法在我心里洒下了种子，第一个，人应该不忘初心，知道自己是怎么一路走到现在的，对geeta来说就是始终得牢记父亲的教诲，不要因为长大了换了一个环境，就把父亲之前交的都丢掉，应该记住自己是怎么一路拿下全国冠军的。第二个，也是之前在B站看见跳水世界冠军吴敏霞的视频里面说的，我们应该尊重每一位运动员，特别是小国家的运动员，因为他们能走到国际比赛的舞台很不容易，小国家的训练设施不齐全，也得不到专业的训练，因此运动员就得不到专业的训练，在之前仅仅听吴敏霞说了之后还没有太多的感触，看完这部电影之后，对这句话的感触特别深。</p>
<p>​        </p>
]]></content>
      <categories>
        <category>感悟</category>
        <category>影视</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--操作系统的概述</title>
    <url>/2020/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="计算机的组成"><a href="#计算机的组成" class="headerlink" title="计算机的组成"></a>计算机的组成</h3><p>硬件+软件</p>
<h3 id="引入操作系统的目的"><a href="#引入操作系统的目的" class="headerlink" title="引入操作系统的目的"></a>引入操作系统的目的</h3><p>方便性、有效性、可扩充性和开放性</p>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul>
<li>是计算机硬件和软件的管理者</li>
<li>是用户使用计算机硬件系统的借口</li>
<li>操作系统是扩展机/虚拟机</li>
</ul>
<h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>操作系统是控制和管理计算机系统的软硬件资源、合理地组织计算机工作流程，</p>
<p>以及方便用户的程序和数据集合。</p>
<h4 id="单道批处理系统的特征"><a href="#单道批处理系统的特征" class="headerlink" title="单道批处理系统的特征"></a>单道批处理系统的特征</h4><ol>
<li><p>自动性:磁带上的一批作业能自动地逐个地依次运行，无需人工干预</p>
</li>
<li><p>顺序性:磁带上的各道作业是顺序地进入内存，各道作业的完成顺序与他们进入内存的顺序之间，在正常情况下应完全相同</p>
</li>
<li><p>单道性:内存中仅有一道程序运行。仅当该程序完成或发生异常情况时才换入其后继程序进入内存运行</p>
<a id="more"></a>

</li>
</ol>
<h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><ol>
<li>处理器管理</li>
<li>存储管理</li>
<li>设备管理</li>
<li>文件管理</li>
<li>用户接口</li>
<li>网络与通信管理</li>
</ol>
<h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><ol>
<li><p>并发性</p>
</li>
<li><p>共享性</p>
<p>a）互斥使用方式   b）同时使用方式</p>
</li>
<li><p>虚拟性</p>
</li>
<li><p>不确定性</p>
<p>a）“走走停停的执行方式”   b）执行结果的不确定性   c）不可预测性</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--操作系统主要类型</title>
    <url>/2020/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><h3 id="单道批处理系统处理流程"><a href="#单道批处理系统处理流程" class="headerlink" title="单道批处理系统处理流程"></a>单道批处理系统处理流程</h3><img src="https://blog.steventan.top/images/操作系统主要类型/4QMJfoxRIXGiu9C.png" alt="image.png" style="zoom:67%;" />

<h3 id="多道批处理操作系统处理流程"><a href="#多道批处理操作系统处理流程" class="headerlink" title="多道批处理操作系统处理流程"></a>多道批处理操作系统处理流程</h3><a id="more"></a>

<img src="https://blog.steventan.top/images/操作系统主要类型/shlfUxnFIu23wdZ.png" alt="image.png" style="zoom:67%;" />

<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p><strong>工作方式：</strong></p>
<p><img src="https://blog.steventan.top/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%9E%8B/clip_image001.png" alt=""></p>
<p>特性：</p>
<ol>
<li>独立性   2. 同时性   3. 交互性   4.及时性</li>
</ol>
<h3 id="分时操作系统和批处理操作系统的区别"><a href="#分时操作系统和批处理操作系统的区别" class="headerlink" title="分时操作系统和批处理操作系统的区别"></a>分时操作系统和批处理操作系统的区别</h3><h4 id="1-追求目标不同"><a href="#1-追求目标不同" class="headerlink" title="1.追求目标不同"></a>1.追求目标不同</h4><p>批处理操作系统一提高系统利用率和吞吐量为主要目标</p>
<p>分时操作系统是为了满足人机交互的需求，方便用户使用</p>
<h4 id="2-使用作业不同"><a href="#2-使用作业不同" class="headerlink" title="2.使用作业不同"></a>2.使用作业不同</h4><p>批处理操作系统适合非交互性的大型作业</p>
<p>分时系统适合交互性的小型作业</p>
<h4 id="3-作业的控制方式不同"><a href="#3-作业的控制方式不同" class="headerlink" title="3.作业的控制方式不同"></a>3.作业的控制方式不同</h4><p>批处理系统是由用户利用作业控制语言，书写作业用户说明书，并预先提交给系统 属于脱机工作</p>
<p>分时系统是由用户直接从键盘敲入命令，来控制作业 属于联机工作</p>
<h4 id="4-资源利用率不同"><a href="#4-资源利用率不同" class="headerlink" title="4.资源利用率不同"></a>4.资源利用率不同</h4><p>批处理操作系统可以合理安排不同负载的作业，使得各种资源均匀工作，利用率高</p>
<p>分时操作系统，只有当多个终端作业使用同类型编译程序和公共子程序，且这些公共子程序是可重用代码的时候系统开销才会比较小</p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p><strong>主要功能和特征：</strong></p>
<ol>
<li>实时时钟管理</li>
<li>过载保护</li>
<li>高可靠性和安全性</li>
</ol>
<h3 id="分时操作系统和实时操作系统区别"><a href="#分时操作系统和实时操作系统区别" class="headerlink" title="分时操作系统和实时操作系统区别"></a>分时操作系统和实时操作系统区别</h3><h4 id="1-设计目标不同"><a href="#1-设计目标不同" class="headerlink" title="1.设计目标不同"></a>1.设计目标不同</h4><p>分时操作系统为用户提供一个通用的交互方式</p>
<p>实时操作系统则是为特殊用途提供的专用操作系统</p>
<h4 id="2-交互性强弱不同"><a href="#2-交互性强弱不同" class="headerlink" title="2.交互性强弱不同"></a>2.交互性强弱不同</h4><p>分时操作系统交互性强</p>
<p>实时操作系统交互性弱</p>
<h4 id="3-响应时间要求不同"><a href="#3-响应时间要求不同" class="headerlink" title="3.响应时间要求不同"></a>3.响应时间要求不同</h4><p>分时操作系统以用户能接受的响应时间为标准</p>
<p>实时操作系统与受控对象及应用场合有关，响应时间变化范围大</p>
<h2 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h2><p>1.单用户单任务（MS DOS）</p>
<p>2.单用户多任务（Windows）</p>
<p>3.多用户多任务</p>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><h3 id="工作模式："><a href="#工作模式：" class="headerlink" title="工作模式："></a>工作模式：</h3><ol>
<li><p>客户服务器模式（client/server，C/S）模式</p>
</li>
<li><p>对等（Peer-to-Peer）模式</p>
</li>
</ol>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ol>
<li>网络通信</li>
<li>资源管理</li>
<li>网络服务（SMTP）</li>
<li>网络管理</li>
<li>互操作能力（NFS）</li>
</ol>
<h2 id="多CPU操作系统"><a href="#多CPU操作系统" class="headerlink" title="多CPU操作系统"></a>多CPU操作系统</h2><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ol>
<li>分布式进程通信</li>
<li>分布式文件系统</li>
<li>分布式进程迁移</li>
<li>分布式进程同步</li>
<li>分布式进程死锁</li>
</ol>
<h2 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol>
<li>微型化</li>
<li>可定制化</li>
<li>实时性</li>
<li>易移植性</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《时生》读后感</title>
    <url>/2020/03/13/%E6%97%B6%E7%94%9F%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>&emsp;&emsp;这本书也是很符合东野圭吾的风格，讲的是穿越的故事，很像我看的他的第一本书——《解忧杂货店》，但是给人的感觉却不一样。</p>
<p>&emsp;&emsp;小说主人公是时生，也就是拓实的儿子，拓实与丽子生下的有重病的儿子。故事是以插叙的手法进描绘的，这也很符合东野圭吾的风格。从拓实和丽子结婚开始，中间插叙了他们认识之前的那些故事，时生穿越时空主要是帮助他爸爸拓实，重新认识自己的身份，放下对其生母美须子的恨意，通过这件事之后也改变了拓实为人处世的态度，让他的生活一步步走向正轨。</p>
<p>&emsp;&emsp;最喜欢的几句原文：</p>
<p>&emsp;&emsp;“未来不仅仅是明天，未来在人心中，只要心中有未来，人就能幸福起来，因为有人教了你母亲这个，她才将你生下来，可你看着自己们整天牢骚满腹，不思进取，你感受不到未来不能怪别人，要怪你自己，因为你是个混蛋！”</p>
<p>&emsp;&emsp;“确信自己喜欢的人能好好地活着，即便面对死亡，也看到了未来。”</p>
]]></content>
      <categories>
        <category>感悟</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>脚本一键部署hexo</title>
    <url>/2020/04/29/%E8%84%9A%E6%9C%AC%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<blockquote>
<p>研究了一下午Windows的批处理文件一个文件只能执行一条语句，执行完之后就直接退出了</p>
<p>解决方法是每条语句放在一个文件里面，通过call调用批处理的文件来执行里面的命令，很简单的几句话要分到好几个文件里面，很不方便。</p>
<p>于是就又看了一下shell脚本，比Windows的批处理脚本要强大太多，shell脚本要在Windows下执行需要安装相关的软件才可以，本版管理工具git的bash命令也可以运行shell脚本。</p>
<p>Windows的批处理脚本主要是不需要安装其他的东西了，可以实现一些简单的功能；但是作为一个码农电脑一般都装了这些相关的可以运行sh脚本的软件，所以用shell脚本也是没问题的，当然用Python写的脚本肯定跟强大，但是要学的东西肯定也跟多。</p>
</blockquote>
<h2 id="windows批处理bat脚本"><a href="#windows批处理bat脚本" class="headerlink" title="windows批处理bat脚本"></a>windows批处理bat脚本</h2><p>主文件</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> .\clean.bat</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 清理完毕</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> .\copyd.bat</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 图片复制完毕</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> .\push.bat</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 编译、部署完毕</span><br><span class="line"></span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>clean.bat</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 开始清理</span><br><span class="line"></span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure>

<p>copyd.bat</p>
<p>这个名字取成copyd主要是怕和系统的关键字或者保留字冲突</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 开始复制图片</span><br><span class="line"></span><br><span class="line"><span class="built_in">xcopy</span> E:\TanXY\Pictures\typora .\source\images\ /e /y</span><br></pre></td></tr></table></figure>

<p>push.bat</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 开始编译部署</span><br><span class="line"></span><br><span class="line">hexo generate -d</span><br></pre></td></tr></table></figure>

<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/sh</span></span><br><span class="line">cp -r E:/TanXY/Pictures/typora/* ./source/images/</span><br><span class="line"><span class="meta">#</span><span class="bash"> -r表示递归</span></span><br><span class="line">echo -e "\e[40;33m图片复制完毕\e[0m"</span><br><span class="line">hexo clean</span><br><span class="line">echo -e "\e[40;33m清理完毕\e[0m"</span><br><span class="line">hexo g -d</span><br><span class="line">echo -e "\e[40;33m编译部署完毕\e[0m"</span><br><span class="line"><span class="meta">#</span><span class="bash"> -e是设置输出的颜色这里40代表黑色的背景，33是黄色字体。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式是\e[背景颜色;字体颜色m显示的内容\e[0m</span></span><br><span class="line"><span class="meta">#</span><span class="bash">不过不想搞得这么花里胡哨就直接忽略吧（滑稽）</span></span><br><span class="line"></span><br><span class="line">read -s -n 1 -p "按任意键退出 ... "</span><br><span class="line"><span class="meta">#</span><span class="bash"> -s输内容入不显示出来  -n指定参数个数，这里是1个  -p提示语句</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统--操作系统的中断</title>
    <url>/2020/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><blockquote>
<p>中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的时间处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。</p>
</blockquote>
<h3 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h3><ol>
<li>解决CPU和I/O设备之间的并行工作问题</li>
<li>实时实现控制</li>
</ol>
<h3 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h3><a id="more"></a>

<ol>
<li>实现CPU和I/O设备并行工作</li>
<li>实现硬件故障处理</li>
<li>实现人机-联系</li>
<li>实现多道程序和分时操作</li>
<li>实现实时处理</li>
<li>实现应用程序和操作系统的联系</li>
<li>实现多处理机系统中处理机之间的联系</li>
</ol>
<h3 id="中断的特点"><a href="#中断的特点" class="headerlink" title="中断的特点"></a>中断的特点</h3><ul>
<li>随机性：在系统的运行过程中，中断事件随时可能出现</li>
<li>可恢复性：完成对某一事件的中断处理程序之后，系统会返回到原程序的断点处继续执行</li>
<li>自动性：在中断时间发生之后，进入中断、执行中断处理程序以及中断返回都是由系统自动完成的</li>
</ul>
<h3 id="中断在操作系统中的地位"><a href="#中断在操作系统中的地位" class="headerlink" title="中断在操作系统中的地位"></a>中断在操作系统中的地位</h3><ol>
<li>是多道程序并发执行的推动力</li>
<li>操作系统是由中断驱动的</li>
</ol>
<h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><pre class="mermaid">graph LR
A[中断]-->B[外中断]
B-->D[可屏蔽中断]
B-->E[不可屏蔽中断]
A-->C[内中断]
C-->F[自愿中断]
F-->G[系统调用]
F-->H[缺页中断]
F-->I[断点指令]
F-->J[其他程序性异常]
C-->K[强迫性中断]
K-->O[硬件故障中断]
K-->L[程序性中断]
K-->M[输入输出中断]
K-->N[外部中断]</pre>

<ul>
<li><p>内中断和外中断：中断来源是否来自计算机内部</p>
</li>
<li><p>外中断：来自CPU外的外部设备，通过硬件请求方式产生的强迫性中断</p>
</li>
<li><p>不可屏蔽中断：有就一定会执行中断</p>
</li>
<li><p>可屏蔽中断：在当前指令结束后，CPU根据中断允许标志位判断是否响应中断，通常用于CPU和外部设备之间的数据交换</p>
</li>
<li><p>强迫性中断：由随机事件和外部请求所引发的，引起强迫性中断的事件不是当前运行程序所期待的</p>
</li>
<li><p>自愿性中断：用户程序在使用中请求操作系统提供某种功能服务，通过执行一条访管指令，称为访管中断或陷阱，是当前运行程序所期待的，用户程序对操作系统的某种需求</p>
</li>
</ul>
<h2 id="中断的响应过程"><a href="#中断的响应过程" class="headerlink" title="中断的响应过程"></a>中断的响应过程</h2><pre class="mermaid">graph TB
A[发出中断信号]-->B[CPU完成当前指令的执行]
B-->C[CPU发送中断答应信号]-->D[关中断]
D-->E[CPU将PWS,PC和CS压入核心栈中]
E-->F[将中断处理程序的入口地址送入IP和CS]
F-->G[保存剩余的CPU状态信息]-->H[开中断]-->I[处理中断]
I-->J[恢复CPU的状态信息]-->K[恢复中断钱的PWS,PC和CS]</pre>

<h3 id="简单概括"><a href="#简单概括" class="headerlink" title="简单概括"></a>简单概括</h3><ol>
<li><p>发现中断源</p>
</li>
<li><p>保护和恢复现场</p>
</li>
<li><p>中断响应</p>
</li>
<li><p>保护现场和传递参数</p>
</li>
<li><p>执行相应的中断服务函数</p>
</li>
<li><p>恢复现场并退出中断</p>
</li>
</ol>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="https://blog.steventan.top/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD/RXkpNUiVHOa2Y48.png" alt=""></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Internet校验和计算示例</title>
    <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<blockquote>
<p>Packet</p>
<p>01 00 F2 03 F4 F5 F6 F7 00 00</p>
<p>(00 00 is the checksum field)</p>
<p>Form the 16-bit words</p>
<p>0100 F203 F4F5 F6F7</p>
<p>Calculate 2’s complement sum</p>
<p>0100 + F203 + F4F5 + F6F7 = 0002 DEEF (store the sum in a 32-bit word)</p>
<p>Add the carries (0002) to get the 16-bit 1’s complement sum</p>
<p>DEEF + 002 = DEF1</p>
<p>Calculate 1’s complement of the 1’s complement sum</p>
<p>~DEF1 = 210E</p>
<p>We send the packet including the checksum 21 0E</p>
<p>01 00 F2 03 F4 F5 F6 F7 21 0E</p>
<p>At the receiving</p>
<p>0100 + F203 + F4F5 + F6F7 + 210E = 0002 FFFD<br>FFFD + 0002 = FFFF</p>
<p>which checks OK.</p>
</blockquote>
<a id="more"></a>

<p>原文链接：<a href="https://blog.csdn.net/qq_34369618/java/article/details/60603867" target="_blank" rel="noopener">https://blog.csdn.net/qq_34369618/java/article/details/60603867</a></p>
<p>翻译一下：</p>
<p>有一个Packet</p>
<p>01 00 F2 03 F4 F5 F6 F7 00 00</p>
<p>(最后四位 00 00 是校验和)</p>
<p>把上面十六位的数据两个两个组合</p>
<p>0100 F203 F4F5 F6F7</p>
<p>将这四个32位的16进制数相加</p>
<p>0100 + F203 + F4F5 + F6F7 = 0002 DEEF </p>
<p>最高位进位的“1”返回到最低位继续加</p>
<p>DEEF + 0002 = DEF1 </p>
<p>再对其结果按位取反</p>
<p>~DEF1 = 210E</p>
<p>21 0E就是这个package的校验</p>
<p>01 00 F2 03 F4 F5 F6 F7 21 0E</p>
<p>接收端也是一样的，两个十六位的数组成一个三十二位的数，再将其全部相加</p>
<p>0100 + F203 + F4F5 + F6F7 + 210E = 0002 FFFD<br>FFFD + 0002 = FFFF</p>
<p>得到的结果为FFFF就没有问题</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯单片机基本模块</title>
    <url>/2020/03/08/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h2><p>蓝桥杯这款单片机是用锁存器来实现引脚的复用的，所以代码写起来很麻烦，总是要开关锁存器</p>
<p>为了偷懒，可以用宏定义来定义每个锁存器打开的代码，也可以用函数来实现</p>
<p><strong>用宏定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y4 P2 = (P2&amp;0x1f)|0x80;  <span class="comment">//led</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y5 P2 = (P2&amp;0x1f)|0xa0;  <span class="comment">//蜂鸣器和继电器</span></span></span><br><span class="line">P0 = <span class="number">0x40</span>; <span class="comment">//蜂鸣器</span></span><br><span class="line">P0 = <span class="number">0x10</span>；<span class="comment">//继电器</span></span><br><span class="line">#define Y6 P2 = (P2&amp;<span class="number">0x1f</span>)|<span class="number">0xc0</span>; <span class="comment">//数码管位选</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y7 P2 = (P2&amp;0x1f)|0xe0; <span class="comment">//数码管段选</span></span></span><br></pre></td></tr></table></figure>

<p><strong>用函数：</strong></p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_channel</span><span class="params">(<span class="keyword">char</span> channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(channel)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0x80</span>; <span class="keyword">break</span>; <span class="comment">//led</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xa0</span>; <span class="keyword">break</span>; <span class="comment">//蜂鸣器和继电器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xc0</span>; <span class="keyword">break</span>; <span class="comment">//数码管位选</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xe0</span>; <span class="keyword">break</span>; <span class="comment">//数码管段选</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数码管的显示问题"><a href="#数码管的显示问题" class="headerlink" title="数码管的显示问题"></a>数码管的显示问题</h2><p>初学者一般都是用延时来实现动态数码管的，但是当要实现的功能多起来了，用延时来实现动态数码管，数码管很容易会闪烁，整体效果就很不好了。</p>
<p>另外一种方法可以是用定时器来扫描数码管，每隔一段时间就进入中断服务函数执行数码管的扫描，只要中断间隔的时间小于人眼的视觉暂留（大概是0.1~0.4s），就看不出来数码管会闪烁了。但是这个方法也有缺点，缺点是整个系统每隔这么短的时间就必须要进入这个中断服务函数，很容易会影响、打断其他程序的执行。现在也有解决方法就是在不能被中断打断的功能执行前关掉中断的开关，执行完之后再打开，显然这个解决方法也只是权宜之计，关掉中断的开关有的时候会影响这个计时器的计时，获得的时间就不是很准确，但是误差会很小吧，十行代码51单片机几毫秒甚至更短的时间就可以执行完。所以第二种方法算是比较好的一种方法了，相对于第一种方法来说。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> smgd[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> smgw[]=&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> smgbuf[<span class="number">8</span>],smg_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_channel</span><span class="params">(<span class="keyword">char</span> channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(channel)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0x80</span>; <span class="keyword">break</span>; <span class="comment">//led</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xa0</span>; <span class="keyword">break</span>;	<span class="comment">//蜂鸣器和继电器</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xc0</span>; <span class="keyword">break</span>; <span class="comment">//数码管位选</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xe0</span>; <span class="keyword">break</span>; <span class="comment">//数码管段选</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>  <span class="comment">//总的初始化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">    smgbuf[i] = <span class="number">10</span>;	<span class="comment">//做初始化，上电数码管全部是熄灭的</span></span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0xff</span>;  <span class="comment">//关掉所有的LED</span></span><br><span class="line">  select_channel(<span class="number">4</span>);</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0x00</span>;  <span class="comment">//关掉继电器和蜂鸣器</span></span><br><span class="line">  select_channel(<span class="number">5</span>);</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_timer</span><span class="params">()</span>	<span class="comment">//初始化计时器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TMOD = <span class="number">0x01</span>;</span><br><span class="line">  TH1 = <span class="number">0xf8</span>;</span><br><span class="line">  TL1 = <span class="number">0x2f</span>;<span class="comment">//2ms</span></span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">  ET1 = <span class="number">1</span>;</span><br><span class="line">  TR1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span>  <span class="comment">//数码管显示函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  smg_num++;</span><br><span class="line">  <span class="keyword">if</span>(smg_num &gt;= <span class="number">8</span>)</span><br><span class="line">    smg_num = <span class="number">0</span>;  <span class="comment">//从0-7循环扫描每一个数码管</span></span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0xff</span>;</span><br><span class="line">  select_channel(<span class="number">7</span>);</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;		<span class="comment">//消影</span></span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0x00</span>;</span><br><span class="line">  select_channel(<span class="number">6</span>);</span><br><span class="line">  P0 = smgw[smg_num];</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0xff</span>;</span><br><span class="line">  select_channel(<span class="number">7</span>);</span><br><span class="line">  P0 = ~smgd[smgbuf[smg_num]];</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> i;</span><br><span class="line">  init();</span><br><span class="line">  init_timer();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">      smgbuf[i] = i;  <span class="comment">//数码管一次显示0-7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer1</span><span class="params">()</span> interrupt 3</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是直接在Typora上面写的，没有编译，应该没有很大问题（手动滑稽）</p>
<p>这样写要改变数码管的值只要改变数组smgbuf[]中的值就行了0-9的数字是和编号一一对应的，其他的特殊符号可以自己手动加。</p>
]]></content>
      <categories>
        <category>备赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯单片机按键</title>
    <url>/2020/04/03/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E6%8C%89%E9%94%AE/</url>
    <content><![CDATA[<blockquote>
<p>蓝桥杯这块板子有矩阵按键和独立按键，可以根据换跳帽来切换，下面简单介绍一下这两种按键的程序和基本的原理。</p>
<p>其他51的板子原理也基本相同，下面的代码也可以参考。</p>
</blockquote>
<h2 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h2><p>相对于矩阵按键，独立按键简单很多，就只有四个按钮，判断四个按键哪个被按下的情况较为简单</p>
<p>独立按键的写法也不止一种，这里就介绍两种</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h3><p>实现比较简单，就是一个个判断，检测到为低电平的话就判断按键按下了。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先对每个按键进行位定义</span></span><br><span class="line">sbit S7  = P3^<span class="number">0</span>;</span><br><span class="line">sbit S6  = P3^<span class="number">1</span>;</span><br><span class="line">sbit S5  = P3^<span class="number">2</span>;</span><br><span class="line">sbit S4  = P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//然后逐一判断哪个按键被按下</span></span><br><span class="line">  <span class="keyword">if</span>(S4 == <span class="number">0</span>)<span class="comment">//按键按下之后会检测到低电平，所以对应引脚检测到低电平就视为按键被按下了</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">5</span>);<span class="comment">//延时消抖</span></span><br><span class="line">    <span class="keyword">if</span>(S4 == <span class="number">0</span>)<span class="comment">//再次检测电平信号</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//按键具体功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(S5 == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(S5 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//按键具体功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(S6 == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(S6 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//按键具体功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(S7 == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(S7 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//按键具体功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a><strong>方法二：</strong></h3><p>检测P3口的低四位，若S4被按下，则第四位P3^3为0，所以P3&amp;0xf的值为0x07，其他三个按键也以此类推。这种方法把按键的检测程序和功能程序分开了，如果不想要按下按键后按键里面的功能一直执行的话，按键功能每次执行完要把按键的值归零，否则单片机会一直执行那个按键里面的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> press_flag = <span class="number">0</span>,key_value = <span class="number">0</span>;<span class="comment">//按下标志</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((P3&amp;<span class="number">0x0f</span>) != <span class="number">0x0f</span>&amp;&amp;!press_flag)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">if</span>((P3&amp;<span class="number">0x0f</span>) != <span class="number">0x0f</span>&amp;&amp;!press_flag)</span><br><span class="line">    &#123;</span><br><span class="line">      press_flag = <span class="number">1</span>;<span class="comment">//按键被按下过后将按下标志置为1</span></span><br><span class="line">      <span class="keyword">switch</span>(P3&amp;<span class="number">0x0f</span>)<span class="comment">//按下的按键对应的为0，与0x0f相与可以判断哪个按键被按下</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x07</span>: key_value = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0b</span>: key_value = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0d</span>: key_value = <span class="number">6</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0e</span>: key_value = <span class="number">7</span>; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((P3&amp;<span class="number">0x0f</span>) == <span class="number">0x0f</span>&amp;&amp;press_flag)<span class="comment">//当没有按键按下但是按下标志为1的时候，要将按下标志置为0</span></span><br><span class="line">    press_flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_func</span><span class="params">()</span><span class="comment">//按键的功能函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(key_value)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">/*按键具体功能*/</span> key_value = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">/*按键具体功能*/</span> key_value = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="comment">/*按键具体功能*/</span> key_value = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: <span class="comment">/*按键具体功能*/</span> key_value = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵按键"><a href="#矩阵按键" class="headerlink" title="矩阵按键"></a>矩阵按键</h2><p>相对于独立按键来说，矩阵按键相对是要复杂一点，这里就介绍一种方法</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>这个方法和上面独立按键的方法2实现的思路差不多。因为51单片机的资源很有限，所以这里用了八个引脚来实现一个4×4的矩阵按键。这里对照一下原理图：</p>
<img src="https://blog.steventan.top/images/蓝桥杯单片机按键/OlN6gpyH14z89KR.png" alt="image.png" style="zoom: 67%;" />

<p>第一步：列扫描，先将P3的低四位置为0，高四位置为1，但是这款单片机的P36和P37被P42和P44代替了，所以P42和P44要单独位定义，然后将其置为1。初始值设置完之后就要进行检测了，因为P3的低四位为0，所以当按键按下时接到对应列的那条线会被拉到低电平P44对应的是第一列，其他参照上面的原理图以此类推。</p>
<p>第二部：行扫描，反过来，将P3的低四位置为1，高两位以及P42和P44置为0，哪一行的按键被按下对应行的值会被置为0，这一步和上面独立按键的扫描相似。</p>
<p>经过行和列的扫描就可以确定下来是那个一个按键被按下了，行和列就可以看成是横坐标和纵坐标，这里是先确定纵坐标，再确定横坐标，通过这样的一个坐标就可以确定被按下按键的位置。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sfr P3 = <span class="number">0xc0</span>;</span><br><span class="line">sbit P42 = P4^<span class="number">2</span>;</span><br><span class="line">sbit P44 = P4^<span class="number">4</span>;</span><br><span class="line">sbit P34 = P3^<span class="number">4</span>;</span><br><span class="line">sbit P35 = P3^<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> key_value = <span class="number">0</span>,key_past = <span class="number">0</span>,key_now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_scan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  P3 = <span class="number">0xf0</span>;<span class="comment">//将低四位置为0，高四位和P42、P44置为1</span></span><br><span class="line">  P42 = <span class="number">1</span>;</span><br><span class="line">  P44 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(P42 != <span class="number">1</span>||P44 != <span class="number">1</span>||P34 != <span class="number">1</span>||P35 != <span class="number">1</span>)<span class="comment">//如果有按键被按下对应引脚会被置为0</span></span><br><span class="line">  &#123;</span><br><span class="line">    key_past = key_now;</span><br><span class="line">    key_now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(key_past == <span class="number">1</span>&amp;&amp;key_now == <span class="number">1</span>))<span class="comment">//按键的松手检测</span></span><br><span class="line">      <span class="built_in">delay</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>((P42 != <span class="number">1</span>||P44 != <span class="number">1</span>||P34 != <span class="number">1</span>||P35 != <span class="number">1</span>)&amp;&amp;!(key_past == <span class="number">1</span>&amp;&amp;key_now == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(P44 == <span class="number">0</span>) key_value = <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(P42 == <span class="number">0</span>) key_value = <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(P35 == <span class="number">0</span>) key_value = <span class="number">12</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(P34 == <span class="number">0</span>) key_value = <span class="number">16</span>;</span><br><span class="line">      P3 = <span class="number">0x0f</span>;</span><br><span class="line">      P42 = <span class="number">0</span>;</span><br><span class="line">      P44 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">switch</span>(P3&amp;<span class="number">0x0f</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x07</span>: key_value += <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0b</span>: key_value += <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0d</span>: key_value += <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x0e</span>: key_value += <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    key_past = key_now;</span><br><span class="line">    key_now = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里没有写按键的功能函数，这个就和独立按键的第二种方法类似，传入key_value的值然后执行对应的功能函数，执行完一次之后如果不想要一直执行的话就在执行完之前将key_value的值归零。</p>
]]></content>
      <categories>
        <category>备赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯单片机超声波模块</title>
    <url>/2020/03/13/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%8D%95%E7%89%87%E6%9C%BA%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>这个超声波模块的工作原理很简单，传感器像两个喇叭一样的东西，一个是负责发送超声波的，另一个负责接收超声波，根据发出到接收的时间间隔就可以算出距离了。</p>
<p>s = v*t/2 </p>
<p>初中物理知识哦。</p>
</blockquote>
<p>就不多说了直接上代码</p>
<a id="more"></a>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> sonic_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> smgbuf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> distance;</span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(sonic_counter &gt;= <span class="number">40</span>)<span class="comment">//每隔一定的时间测量一次，必须要加否则测的数据不正确</span></span><br><span class="line">    &#123;</span><br><span class="line">      distance = measure_distance();</span><br><span class="line">      sonic_counter = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    smgbuf[<span class="number">5</span>] = distance/<span class="number">100</span>;</span><br><span class="line">    smgbuf[<span class="number">6</span>] = distance%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">    smgbuf[<span class="number">7</span>] = distance%<span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer2</span><span class="params">()</span> interrupt 12<span class="comment">//定时器2（52单片机多出来的一个定时器）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sonic_counter++;</span><br><span class="line">  <span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>common.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMMON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sonic.h"</span></span></span><br><span class="line"></span><br><span class="line">sfr AUXR = <span class="number">0x8e</span>;</span><br><span class="line">sfr IE2 = <span class="number">0xaf</span>;</span><br><span class="line">sfr T2H = <span class="number">0xd6</span>;</span><br><span class="line">sfr T2L = <span class="number">0xd7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_channel</span><span class="params">(<span class="keyword">char</span> channel)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_timer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>common.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> smgw[<span class="number">8</span>] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> smgd[] = &#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x07</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> smgbuf[<span class="number">8</span>],num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_channel</span><span class="params">(<span class="keyword">char</span> channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(channel)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0x80</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xa0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xc0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: P2 = P2&amp;<span class="number">0x1f</span>|<span class="number">0xe0</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    smgbuf[i] = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0xff</span>;</span><br><span class="line">  select_channel(<span class="number">4</span>);</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0x00</span>;</span><br><span class="line">  select_channel(<span class="number">5</span>);</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">  </span><br><span class="line">  init_timer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_timer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AUXR = AUXR&amp;<span class="number">0x33</span>|<span class="number">0x10</span>;<span class="comment">//定时器2的配置</span></span><br><span class="line">  IE2 = <span class="number">0x04</span>;</span><br><span class="line">  T2H = <span class="number">0xf8</span>;</span><br><span class="line">  T2L = <span class="number">0x2f</span>;</span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  TMOD = <span class="number">0x01</span>;<span class="comment">//定时器1的配置，用于计算发送和接收之间的时间间隔</span></span><br><span class="line">  TH1 = <span class="number">0</span>;</span><br><span class="line">  TL1 = <span class="number">0</span>;</span><br><span class="line">  TR1 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  num++;</span><br><span class="line">  <span class="keyword">if</span>(num &gt;= <span class="number">8</span>)</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0xff</span>;</span><br><span class="line">  select_channel(<span class="number">7</span>);</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0x00</span>;</span><br><span class="line">  select_channel(<span class="number">6</span>);</span><br><span class="line">  P0 = smgw[num];</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">  </span><br><span class="line">  P0 = <span class="number">0xff</span>;</span><br><span class="line">  select_channel(<span class="number">7</span>);</span><br><span class="line">  P0 = ~smgd[smgbuf[num]];</span><br><span class="line">  P2&amp;= <span class="number">0x1f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sonic.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SONIC_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SONIC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> somenop &#123;_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以参照原理图</span></span><br><span class="line">sbit tx = P1^<span class="number">0</span>;<span class="comment">//发送波传感器的引脚</span></span><br><span class="line">sbit rx = P1^<span class="number">1</span>;<span class="comment">//接收波传感器的引脚</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_wave</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">measure_distance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>sonic.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sonic.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_wave</span><span class="params">()</span><span class="comment">//发送超声波</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//发送一组超声波</span></span><br><span class="line">  &#123;</span><br><span class="line">    tx = <span class="number">1</span>;</span><br><span class="line">    somenop;somenop;somenop;somenop;somenop;somenop;somenop;somenop;</span><br><span class="line">    tx = <span class="number">0</span>;</span><br><span class="line">    somenop;somenop;somenop;somenop;somenop;somenop;somenop;somenop;</span><br><span class="line">  &#125;</span><br><span class="line">  TR1 = <span class="number">1</span>;<span class="comment">//定时器1开始计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">measure_distance</span><span class="params">()</span><span class="comment">//计算、测量距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> distance;</span><br><span class="line">  send_wave();<span class="comment">//先发送</span></span><br><span class="line">  <span class="keyword">while</span>(rx == <span class="number">1</span>&amp;&amp;TF1 == <span class="number">0</span>);<span class="comment">//等待接收完毕或者定时器1溢出</span></span><br><span class="line">  TR1 = <span class="number">0</span>;<span class="comment">//定时器1停止计时</span></span><br><span class="line">  <span class="keyword">if</span>(rx == <span class="number">0</span>&amp;&amp;TF1 == <span class="number">0</span>)<span class="comment">//正常量程之内</span></span><br><span class="line">  &#123;</span><br><span class="line">    distance = ((TH1&lt;&lt;<span class="number">8</span>)+TL1)*<span class="number">0.017</span>;<span class="comment">//计算距离</span></span><br><span class="line">    TH1 = <span class="number">0</span>;</span><br><span class="line">    TL1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    distance = <span class="number">999</span>;<span class="comment">//超出量程</span></span><br><span class="line">    TF1 = <span class="number">0</span>;</span><br><span class="line">    TH1 = <span class="number">0</span>;</span><br><span class="line">    TL1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>备赛</category>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>蓝桥杯</tag>
      </tags>
  </entry>
</search>
